<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/sign.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/small.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hnu-legend1440.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第二章 RCE 与正则表达式PHP 命令执行(续上周的学习)个人的所有作业中,带的小点为做题补充知识点 二 替换绕过函数过滤(即使用特定的函数或者不被过滤的函数执行命令)1.记住常见的可执行函数  2.LD_PRELOAD(修改库文件)绕过(用于面对禁用函数者过多的情况) 它可以影响程序的运行时的链接,允许你定义在程序运行前优先加载的动态链接库。 因而可以向库文件种中注入恶意程序 putenv(“">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章 RCE与正则表达式">
<meta property="og:url" content="http://hnu-legend1440.com/2026/01/19/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RCE%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html">
<meta property="og:site_name" content="拂云观 · legend1440">
<meta property="og:description" content="第二章 RCE 与正则表达式PHP 命令执行(续上周的学习)个人的所有作业中,带的小点为做题补充知识点 二 替换绕过函数过滤(即使用特定的函数或者不被过滤的函数执行命令)1.记住常见的可执行函数  2.LD_PRELOAD(修改库文件)绕过(用于面对禁用函数者过多的情况) 它可以影响程序的运行时的链接,允许你定义在程序运行前优先加载的动态链接库。 因而可以向库文件种中注入恶意程序 putenv(“">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hnu-legend1440.com/images/YTOjbBuyboX4EFxc64EcBL17n7c.png">
<meta property="article:published_time" content="2026-01-18T18:37:34.000Z">
<meta property="article:modified_time" content="2026-01-19T06:53:01.671Z">
<meta property="article:author" content="legend1440">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hnu-legend1440.com/images/YTOjbBuyboX4EFxc64EcBL17n7c.png">

<link rel="canonical" href="http://hnu-legend1440.com/2026/01/19/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RCE%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第二章 RCE与正则表达式 | 拂云观 · legend1440</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拂云观 · legend1440</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/categories/schedule/" rel="section"><i class="fa fa-axe fa-fw"></i>期末突击</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-training">

    <a href="/categories/training/" rel="section"><i class="fa fa-archive fa-fw"></i>集训</a>

  </li>
        <li class="menu-item menu-item-wp">

    <a href="/categories/WP/" rel="section"><i class="fa fa-archive fa-fw"></i>赛题WP</a>

  </li>
        <li class="menu-item menu-item-puzzles">

    <a href="/categories/puzzles/" rel="section"><i class="fa fa-archive fa-fw"></i>解题记录</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hnu-legend1440.com/2026/01/19/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RCE%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="legend1440">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拂云观 · legend1440">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第二章 RCE与正则表达式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-19 02:37:34 / 修改时间：14:53:01" itemprop="dateCreated datePublished" datetime="2026-01-19T02:37:34+08:00">2026-01-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/training/" itemprop="url" rel="index"><span itemprop="name">-training</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第二章-RCE-与正则表达式"><a href="#第二章-RCE-与正则表达式" class="headerlink" title="第二章 RCE 与正则表达式"></a>第二章 RCE 与正则表达式</h1><h1 id="PHP-命令执行-续上周的学习"><a href="#PHP-命令执行-续上周的学习" class="headerlink" title="PHP 命令执行(续上周的学习)"></a><strong>PHP 命令执行(续上周的学习)</strong></h1><p><em><em>个人的所有作业中,带</em>的小点为做题补充知识点</em></p>
<h2 id="二-替换绕过函数过滤-即使用特定的函数或者不被过滤的函数执行命令"><a href="#二-替换绕过函数过滤-即使用特定的函数或者不被过滤的函数执行命令" class="headerlink" title="二 替换绕过函数过滤(即使用特定的函数或者不被过滤的函数执行命令)"></a>二 替换绕过函数过滤(即使用特定的函数或者不被过滤的函数执行命令)</h2><p><strong>1.记住常见的可执行函数</strong></p>
<p><img src="/images/YTOjbBuyboX4EFxc64EcBL17n7c.png"></p>
<p><strong>2.LD_PRELOAD(修改库文件)绕过(用于面对禁用函数者过多的情况)</strong></p>
<p>它可以影响程序的运行时的链接,允许你定义在程序运行前优先加载的动态链接库。</p>
<p>因而可以向库文件种中注入恶意程序</p>
<p>putenv(“LD_PRELOAD&#x3D;文件路径”) 这个语句就代表加载动态链接库.</p>
<p>我们需要的就是修改动态链接库中代表某个 php 函数的动作.</p>
<p>再运行这个函数时 便可以运行恶意程序.</p>
<p>下面以经典的修改库文件函数 mail 为例叙述具体流程:</p>
<p>(1)在修改库文件时，先要找出 mail 函数调用了子进程的什么内容(子进程的运行则基于一些以 C 语言为基础的函数).</p>
<p>我们在名为 demo.php 程序中写入 mail 函数并运行</p>
<p>(2)再从 cmd 上输入 strace -o 1.txt -f php demo.php(修改的是 mail 函数普适执行的程序,因此在控制台下进行)</p>
<p>把 demo.php 执行的动作，以文本方式放在 1.txt</p>
<p>(3)再用#cat 1.txt | grep execve 获取 1.txt 的内容,用后面的参数独一地检查调用了哪些子进程</p>
<p>发现在调用的”sendmail”子进程可能代表的是 mail 函数,并且看到了 sendmail 的路径</p>
<p>(4)最后使用 readelf -Ws&#x2F;usr&#x2F;sbin&#x2F;sendmail</p>
<p>查看 sendmail 调用了哪些函数</p>
<p>找到一个明显可以修改定义的函数 getuid()</p>
<p>(5)用#vim demo2.c 手写一个 getuid()的定义,再用#gcc -shared -fPIC demo2.c-O demo2.so</p>
<p>将带有命令的 c 文件编译成为.so 文件，生成动态链接库文件并用上文所提的 putenv 手动添加库文件</p>
<p>(注意:库文件一般以.so 为后缀,但内容为 C 代码)</p>
<p>这样就改变了 mail 函数的进程.</p>
<p>综上 就有一些绕过条件</p>
<p>第一是能够上传自己的.so 文件；</p>
<p>第二是能够控制环境变量的值（设置 LD_PRELOAD 变量），比如 putenv 函数并且未被禁止；</p>
<p>(实际上 可使用蚁剑上的插件直接绕过函数过滤[disable_function]),让过滤的函数有用.上文是为了解释原理.)</p>
<h2 id="三-操作系统连接符"><a href="#三-操作系统连接符" class="headerlink" title="三 操作系统连接符"></a>三 操作系统连接符</h2><p>在 php 命令执行函数中,字符串代表的命令是可用的,字符串中的链接符亦然有用.</p>
<p>所以若出现 system(“ls”.$_GET(a))</p>
<p>可以在 a 前加操作系统链接符以执行 ls 和 a 代表的命令.</p>
<p>&amp;&amp;（逻辑与运算符）: 只有当第一个命令 cmd_1 执行成功（返回值为 0）时，才会执行第二个命令 cmd_2。例:  mkdir test &amp;&amp; cd test</p>
<p>||（逻辑或运算符）: 只有当第一个命令 cmd_1 执行失败（返回值不为 0）时，才会执行第二个命令 cmd_2。例:  cd nonexistent_directory || echo “Directory not found”</p>
<p>&amp;（后台运行符）: 将命令 cmd_1 放到后台执行，Shell 立即执行 cmd_2，两个命令并行执行。例:  sleep 10 &amp; echo “This will run immediately.”</p>
<p>;（命令分隔符,推荐）: 无论前一个命令 cmd_1 是否成功，都会执行下一个命令 cmd_2。例:  echo “Hello” ; echo “World”</p>
<h2 id="四-空格过滤绕过"><a href="#四-空格过滤绕过" class="headerlink" title="四 空格过滤绕过"></a>四 空格过滤绕过</h2><p><strong>1.preg_replace 函数</strong></p>
<p>preg_replace(“M”,”N”,$a)</p>
<p>将 $a 变量中##中间的 M 字符(串)或者字符串替换为 N 字符</p>
<p>并且返回值为替换后的 $a.</p>
<p>注意 如果要替换空格 M 要换成# #</p>
<p><strong>2.用大括号的形式绕过空格</strong></p>
<p>cmd&#x3D;{ls,-l},逗号代表空格,也可以正常执行 ls -l.</p>
<p><strong>3.IFS(内部字段分隔符)代替空格；</strong></p>
<p>$IFS ${IFS}(推荐) $IFS$9 都可以代替空格.</p>
<p><strong>4.UR 编码 09%</strong></p>
<p>09% 代表 tab 键表示的空格,可以绕过正常的空格</p>
<h2 id="五-文件名过滤绕过"><a href="#五-文件名过滤绕过" class="headerlink" title="五 文件名过滤绕过"></a>五 文件名过滤绕过</h2><p><strong>0.如果是换命令 换成其他的能够执行命令的函数</strong></p>
<p><strong>1.通配符?绕过</strong></p>
<p>fl?g 代表?位置的字符不确定 可以绕过 flag 一整个字符串的过滤.</p>
<p><strong>2.通配符*绕过</strong></p>
<p>fl* *ag *可以代表任何字符串</p>
<p>cat *可以查看全部的文件</p>
<p><strong>3.在匹配字符串的时候添加””或者’’</strong></p>
<p>fl’’ag 也可以绕过 flag 一整个字符串的过滤</p>
<p>*<em>4.用转义字符*</em></p>
<p>\在过滤字符的时候会被包含 但是执行指令的时候不会</p>
<p>注意+字符可能会有其他含义 要规避</p>
<p><strong>5.用 $+ 数字&#x2F;@&#x2F;</strong>*</p>
<p>代表的为空 相当于单引号或双引号.</p>
<p><strong>6.内联执行</strong></p>
<p>自定义字符串，再拼接起来.</p>
<p>a&#x3D;f;d&#x3D;ag;c&#x3D;l;cat $a$c$d.txt</p>
<p><strong>7.在环境变量中提取字符</strong></p>
<p>已知环境变量 PATH 为一个路径,且第五个字符为 l</p>
<p>#echo f${PATH:5:1}</p>
<p>可以使用环境变量 PATH 里的第五个字符，（从 0 开始计数，l 为第五个字符）</p>
<p>来显示 1 个字符；</p>
<p>fl</p>
<h2 id="六-常见文件读取指令绕过-通常为过滤-cat"><a href="#六-常见文件读取指令绕过-通常为过滤-cat" class="headerlink" title="六 常见文件读取指令绕过(通常为过滤 cat)"></a>六 常见文件读取指令绕过(通常为过滤 cat)</h2><p>1.tac 反向显示 将倒数第一行显示为第一行 以此类推 但是同一行中的方向不变</p>
<p>2.more 按页显示 敲空格往后翻页</p>
<p>3.less 与 more 同理</p>
<p>4.tail 查看末尾若干行</p>
<p>5.nl 显示的时候顺便显示行号</p>
<p>6.od&#x2F;xxd 以二进制形式读取</p>
<p>7.sort 用于排序文件 效果与 cat 也相似.</p>
<p>8.uniq:报告或删除文件中重复的行 与 cat 效果相似.</p>
<p>9.执行错误的 php 文件(通常只有 flag 这一行的 php 文件是错误的.),并使用 file -f 报错出具体的内容.</p>
<p>例如 passthru(“file -f flag.php”); flag.php 没有办法执行 因此会报错出这个程序的具体内容 其中可能包含 flag</p>
<p>10.grep：在文本中查找指定的字符串所对应的行 并输出这一行</p>
<p>例如 cmd&#x3D;passthru(“grep fla fla*”);</p>
<p>从 fla*文本文件中搜索包含”fla”字符串的行.</p>
<h2 id="七-编码绕过-对提交的命令进行编码"><a href="#七-编码绕过-对提交的命令进行编码" class="headerlink" title="七 编码绕过(对提交的命令进行编码)"></a>七 编码绕过(对提交的命令进行编码)</h2><p>(基础不足 暂时略过)</p>
<h2 id="八-斜杠绕过"><a href="#八-斜杠绕过" class="headerlink" title="*八 斜杠绕过"></a>*八 斜杠绕过</h2><p>这种情况通常为文件路径无法输入 可以用 cd 更换工作目录</p>
<p>再用 cat 直接加文件名进行文件输出</p>
<h2 id="九-多个指令的执行"><a href="#九-多个指令的执行" class="headerlink" title="*九 多个指令的执行"></a>*九 多个指令的执行</h2><p>不仅可以用;还可以用 %0a(推荐,对应换行符) %0d(回车符) %0D%0A 作为多个指令的分隔同时执行多个指令.</p>
<p>注意:回车符（%0d）本身不换行，仅光标回行首；换行符（%0a）仅光标下移一行。</p>
<p>两者组合（%0d%0a，即 \r\n）才是「完整的换行逻辑」，也是最通用的跨场景换行格式.</p>
<h1 id="PHP-函数安全"><a href="#PHP-函数安全" class="headerlink" title="PHP 函数安全"></a>PHP 函数安全</h1><p>在 PHP 中，除了上周学的⼏个命令执⾏函数，还有⼀些危险函数存在⼀些攻击点，也是 ctf ⽐较常⻅的出题点.</p>
<h2 id="1-is-numeric-绕过"><a href="#1-is-numeric-绕过" class="headerlink" title="1.is_numeric 绕过"></a>1.is_numeric 绕过</h2><p>作用：检测变量是否是数字或数字字符串 返回值为 bool。</p>
<p>e.g.</p>
<?php

$a = $_GET['a'];

if (is_numeric($a)) {

    exit();

} elseif ($a == 404) {

    echo "flag";

}

我们要将$a用get方式更改为404 但该函数能够检测变量是数字

通过在数字前面或者后面加上%0a %0b %0c %0d %09等文件名过滤绕过的方法绕过



## 2.PHP精度

可使用IEEE 754 标准在线转换网站：https://tooltt.com/floatconverter/

进行进制转换.

(注:基本上所有语言双精度格式都采用 IEEE 754)

用精度漏洞可用x.99999999999999999来绕过对x+1数字的限制.



## 3.比较和类型转换漏洞

PHP 包含 松散 和 严格 比较

松散比较（==）比较值，但不比较类型，严格比较（===）即比较值也比较类型

echo (123 == "123")?1:0;

返回:1

echo (123 === "123")?1:0;

返回:0



注： 字符串转成数字后会是 0,而不是对应的ASCII码值.



var_dump(0 == "a");

返回： 1（0 & 0 自然为1）



$id = intval("12312a");

var_dump($id);

输出：12312

在 PHP 中类型转换有一定的缺陷，如果一个 字符串 要转成数值类型，首先对字符串进行一个判断，

如果字符串包含 e 、. 、E 则会作为 float 来取值，否则则为 int ，上述例子由于 a 没有包含任何东西，

所以被当作 int 来处理了，

这里要说明的是，如果字符串起始部分为 数值 ，则采用 起始的数值 ，否则一律为 0



需要注意的是科学计数法和十六进制也会被识别出来

var_dump(100 == "1e2"); #采用科学计数法

返回：true

var_dump(23333 == "0x5b25"); #采用十六进制

返回：true



在 PHP8.0.0 之前（最新版本已修复），如果 字符串 与 数字 或者 数字字符串 进行比较，

则会先进行 类型转换 再进行比较。

最新版本直接识别为string string==0会返回false了.





## 4.PHP 弱类型比较

判断原始变量类型的函数(注意 PHP的变量不存在先声明后定义 一定要定义)

**(1)gettype($var)返回变量的「原始类型字符串」，**

直接告诉你变量是什么类型（如 int、string、null 等）。

(必须传已定义的变量)

**(2)empty($var) —— “空值检测器”**

判断变量是否为「空值」（宽松判断，不区分类型，只要是 “无意义” 的值都算空）。

以下值会被判定为「空」，返回 true，其余返回 false：

未定义的变量（$var 没声明）；

null（显式赋值为 null）；

布尔值 false；

数值 0、0.0（整数 0、浮点数 0）；

空字符串 ""、字符串 "0"（注意：仅 "0" 算空， "00"、"false" 不算）；

空数组 []（count($var) == 0）；

(可以传未定义的变量)

**(3)is_null($var) —— “严格 null 判断器”**

核心作用：仅判断变量是否为「严格的 null」（比 empty 严格 10 倍，只认 null）。

(必须传已定义的变量)

**(4)isset($var) —— “变量存在检测器”**

判断变量「是否已定义」且「值不为 null」（重点：检测 “存在性”，而非 “空值”）。

已定义但值为 null → 返回 false；

已定义且值不为 null → 返回 true（即使值是 0、""、[] 等空值也返回 true）；

支持多变量判断：isset($a, $b, $c) → 所有变量都存在且非 null 才返回 true。

(可以传未定义的变量,返回 false（不报错）；)

**(5)if($x) —— 布尔值隐式转换（“真值检测器”）**

将变量 $x 隐式转换为布尔值 true/false，判断变量是否为「真值」

（逻辑和 empty() 几乎相反，但有细微差异）。

以下值会被转为 false（和 empty() 判定为 “空” 的规则一致）：

null、false、0、0.0、""、"0"、[]；

其余值（如 " "、1、"abc"、["a"] 等）都会转为 true。

(必须传已定义的变量)

**(6)弱类型比较表格**

https://www.php.net/manual/zh/types.comparisons.php#types.comparisions-loose

(最重要的:0==Null true)

**(7)strcmp函数**

描述：strcmp(str1, str2)

如果 str1 小于 str2 返回 < 0； 如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0。

(注： 在 php5.0 以前，strcmp 返回的是 str2 第一位字母转成 ascii 后减去 str1 第一位字母。)

当 strcmp 比较出错后，会返回 null，null 则为 0，举个例子



$flag = 'flag{123}';

if (strcmp($flag, $_GET['str']) == 0) {

    echo $flag;

}else{

    echo "Out!";

}



为了使 strcmp 比较出错，可以传入一个数组

非空数组和变量无法正常比较.

**(8)is_numeric函数**

is_numeric() 用于检测数值是否为数值，如果遇到这个函数，可以用上述转换类型的特性

（版本小于 8.0.0），如果传入的是字符串，会先将字符串转换成数值:

(在 PHP8.0.0 之前（最新版本已修复），如果 字符串 与 数字 或者 数字字符串 进行比较，

则会先进行 类型转换 再进行比较。

最新版本直接识别为string string==0会返回false了.)



$flag = 'flag{111}';

$id = $_GET['id'];

if(is_numeric($id) > 0){

    echo 'Out!';

}else{

    if ($id > 233) {
        echo $flag;

    }

}



Payload: ?id=2333,

Payload: ?id=2333%00

Payload: ?id=2333A

**(9)is_switch函数**

is_switch()¶



这个方法和类型转换一样大同小异，case 会自动将字符转换成数值。这里来个例子就知道了



$a = "233a"; # 注意这里

$flag = "flag{Give you FLAG}";

switch ($a) {
    case 1:
        echo "No Flag";
        break;
    case 2:
        echo "No Flag";
        break;
    case 233:
        echo $flag;

        break;

    default:

        $a = 233;

        echo "Haha...";

}



输出：flag{Give you FLAG}

**(10)sha1()函数**

sha1() 是 PHP 中用于计算字符串 SHA-1 哈希值 的内置函数，属于哈希算法的一种，

核心用途是将任意长度的字符串转换为固定长度（40 个字符）的 16 进制字符串

sha1 的参数不能为数组，传入数组会返回 NULL，所以先传一个数组使得 sha1 函数报错，

接着再左右两边传入不一样的内容，两边条件自然 =1，相等即可绕过.

$flag = "flag{Chain!}";

$get = $_GET['get'];

$teg = $_GET['teg'];

if ($get != $teg && sha1($get) === sha1($teg)) {

#if ($get != $teg && sha1($get) == sha1($teg)) {

    echo $flag;

}else{

    echo 'Out!';

}



Payload: ?get[]=&teg[]=1



**(11)md5**

描述：md5(字符串,字符串,var2)

计算 字符串 的 MD5 散列值，如果 var2 为真将返回 16 字符长度的原始二进制格式

md5 在处理哈希字符串的时候，如果 md5 编码后的哈希值时 0e （科学计数法）开头的，都一律解释为 0，

所以当两个不同的值经过哈希编码后他们的值都是以 0e 开头的，则每个值都是 0

(他们用松散等于是相等的 但严格等于未必!)

var_dump(0e912 == 0e112?1:0);

输出：1

常见 md5 以 0e 开头的值

数值型

240610708 0e462097431906509019562988736854 返回：0

314282422 0e990995504821699494520356953734 返回：0

571579406 0e972379832854295224118025748221 返回：0

903251147 0e174510503823932942361353209384 返回：0



字母型

QLTHNDT 0e405967825401955372549139051580 返回：0

QNKCDZO 0e830400451993494058024219903391 返回：0

EEIZDOI 0e782601363539291779881938479162 返回：0

TUFEPMC 0e839407194569345277863905212547 返回：0



**(11.1)==弱类型比较的处理方法**

$flag = "flag{THIS_IS_REAL_FLAG}";

$v1 = $_GET['gat'];

$v2 = $_GET['tag'];

if ($v1 != $v2 && md5($v1) == md5($v2)) {

    echo $flag;

}else{

    echo "Out!";

}



v1 和 v2 是两个参数变量，首先 v1 不等于 v2，意思就是两个值必须不相同，

其次 md5 后的 v1 和 md5 后的 v2 必须相同，这时候就可以使用上述 0e 方法构造 Payload，

只需找出哪个值经过 md5 编码后以 0e 开头即可



Payload: ?gat=240610708&tag=314282422



**(11.2)数组比较法绕过===比较**

如果遇到下列程序



$flag = "flag{THIS_IS_REAL_FLAG}";

$str1 = $_GET['gat'];

$str2 = $_GET['tag'];

if (md5($str1) === md5($str2)) {

    echo $flag;

}



用上述 0e 方法自然是不可行的（注意：===），这时候就得使用数组来绕过了

如果传入一个数组的值，会报出错误（md5 只能使用字符串），报错后就相当于绕过===这个条件了

(注： 在 PHP 8.0.0 时，该方法行不通了)



**(11.3)md5 碰撞(即md5相同而内容完全不一样的字符串)**

如果遇到不能传入数组，只能传入字符串的时候，如下例



$flag = "flag{THIS_IS_REAL_FLAG}";

$str1 = $_GET["gat"];

$str2 = $_GET["tag"];

if((string)$str1 !== (string)$str2 && md5($str1)===md5($str2)){

    echo "flag{THIS_IS_REAL_FLAG}";

}else{

    echo "Out!";

}



这时候就得需要 md5 碰撞((string)转化让第二个条件===无法返回null,不然也可以用第二点的数组绕过)，

上面判断条件的意思是，str1 和 str2 内容必须不同，但是 md5 必须相同。

这里可以使用工具构造

240610708

314282422

存在MD5碰撞漏洞



**(12)变量覆盖漏洞**

变量如果未被初始化，且能够被用户所控制，那么很可能会导致安全问题，前提是环境开启了



register_globals=ON



如果传入一个参数 ?id=1，并且这个参数把原有的变量值给覆盖掉了则叫做 变量覆盖漏洞

例如

<?php

$flag = "flag{Chain!}";

$a = "A";

$b = "B";

echo "$a" . "\n";

echo "$b" . "\n";

$a = $_GET['get'];  # $a 变量被我们传入的get给覆盖掉了

echo $a . "\n";

echo $b . "\n";



传入参数：?get=Genshin，返回

a:A

b:B

a:Genshin

b:B



漏洞产生原因大致有:

register_globals（全局变量）为 On

$$ 使用不恰当
extract() 函数使用不当
parse_str() 使用不当
import_request_variables() 使用不当

(12.1)$$

在 PHP 中，$$ 是可变变量（Variable Variables） 的语法，核心作用是：用一个变量的值作为另一个变量的名称。

简单说：如果有一个变量 $a = "name"，那么 $$a 就等价于 $name（把 $a 的值 "name" 当作了新变量的名称）。



**(12.2)extract()**

描述：extract(array,flags,prefix)



array：数组

flags(相当于模式的选择)：

    EXTR_OVERWRITE - 如果有冲突，覆盖已有的变量。（默认）

    EXTR_SKIP - 如果有冲突，不覆盖已有的变量。

    EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。（需要第 prefix 参数）

    …

prefix：该参数规定了前缀。前缀和数组键名之间会自动加上一个下划线。

即若数组中有"a"=>"STR"

变量又存在"a"="STR2"

则EXTR_PREFIX_SAME模式下不会把STR赋给a,而会创建一个<前缀>_a的变量并把值赋给他    

extract 用来将变量从数组中导入到当前的符号表中，并返回成功导入到符号表中的变量数目

例

$a = "Source";

$array = array(

    "a"=>"JP",

    "b"=>"RU",

    "c"=>"US",

);

extract($array);

echo "\$a = " . $a . "<br>"; # 注意这里，a原本是有内容的

echo "\$b = " . $b . "<br>";

echo "\$c = " . $c . "<br>";



返回



$a = JP

$b = RU

$c = US



(注意:extract($_POST); 的核心意思是：将前端通过 POST 请求提交的所有数据（存储在 $_POST 关联数组中）

批量转为当前作用域的 PHP 变量—— 数组的「键名」会变成变量名，数组的「键值」会变成变量值。)

(假设前端通过表单 / POST 请求发送了 3 个变量：username=张三、age=25、email=zhangsan@example.com，那么 PHP 接收后：

$_POST 数组的结构是：["username" => "张三", "age" => 25, "email" => "zhangsan@example.com"]

执行 extract($_POST); 后，会自动创建 3 个变量：

$username = "张三"（键名 username → 变量名 $username，键值为值）

$age = 25（键名 age → 变量名 $age）

$email = "zhangsan@example.com"（键名 email → 变量名 $email）

之后你可以直接用 $username、$age 访问数据，无需再写 $_POST['username']。)

**(12.3)parse_str(str)**

描述：parse_str(str) 用于将字符串解析成多个变量(也可以为单个变量)，没有返回值\



parse_str("username=A&password=123456");

echo "Username: " . $username . "<br>";

echo "Password: " . $password;



输出



Username: A

Password: 123456



原本这个函数有 array 参数的，但在 7.2 后废除了，array 变量会以数组元素的形式存入到这个数组，作为替代



来到例题



$UIUCTF = "UIUCTF Hacker.";

$id = $_GET['id'];

@parse_str($id);

if ($a[0] != 'QNKCDZO' && md5($a[0]) == md5('QNKCDZO')) {

    echo $flag;

}else{

    echo "Out!";

}

#QNKCDZO = 0e830400451993494058024219903391



注意第四行，和前面的 md5 比较有关系，但不同的是这里加入了 parse_str 这个函数，这段代码大致意思就和上面 md5 绕过的意思一样，如果 md5 编码后的哈希值时 0e （科学计数法）开头的，都一律解释为 0，所以当两个不同的值经过哈希编码后他们的值都是以 0e 开头的，则每个值都是 0，与众不同的是我们要覆盖掉 a[0] 这个变量



Payload: ?id=a[0]=240610708



**(12.4)register_globals**

register_globals 设置为 on 的时候，传递的参数会 自动注册 为全局变量。

ini_set("register_globals", "On");

echo $a;



**(13)伪协议**

(基础不足，暂时略过)



# 正则表达式基本语法 

正则表达式是⼀种⽤于匹配和操作⽂本的强⼤⼯具，它是由⼀系列字符和特殊字符组成的模式，⽤于 

描述要匹配的⽂本模式。 

正则表达式可以在⽂本中查找、替换、提取和验证特定的模式。 

例如： 

• runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前⾯的字符必须⾄少出现⼀ 

次（

1次或多次） 

• runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表前⾯的字符可以不出现，也可 

以出现⼀次或者多次（

0次、或1次、或多次） 

• colou?r 可以匹配 color 或者 colour，? 问号代表前⾯的字符最多只可以出现⼀次（

0次或1次） 

正则分隔符:（

PHP 正则需⽤ / 或 # 等包裹）例如/runoo*b/ 

⼦表达式:不加括号的时候是前⼀个字符,加括号时是前⼀个括号内的字符 

例如colo(ur)?可以匹配colo. 

## **正则表达式的基本语法与应用**

**(1)指定⼦表达式的出现次数 **

除了上⾯举例中的?,*和+外,还有⼀些⽅式可以指定⼦表达式的出现次数. 

ab{2}c 表⽰指定ac之中出现b的次数为2次 

ab{2,6}c 表⽰指定ac之中出现b的次数为2-6次 

ac{2,}c 即为表⽰指定ac之中出现b的次数⼤于等于2次 

**(2)正则表达式的逻辑运算符 **

|表⽰或 配合()⼀起使⽤ 例如a(b|c),匹配ab或ac 

**(3)字符类运算符 **

[]+ ⽅括号的内容表⽰匹配的字符只能取⾃他们,注意是每⼀个字符,不是字符串 

_(这⾥可以思考⼀下preg_match函数中()和[]的区别,|⽤在哪个地⽅会使()和[]等价) _

不同字符中间也不需要分隔 

[abc]+ 能匹配到abc aabbcc等 

[a-z]+ 能匹配到所有带有⼩写字⺟的字符串 

[a-zA-z0-9]+ 能匹配到所有带有⼩写字⺟,⼤写字⺟或数字的字符串 

如果在⽅括号最开始加^,即代表否定,[^abc],则代表匹配⽆三个字⺟abc的字符串注:带⽅括号的整体为⼀整个⼦表达式 

如可按照\a[abc]{1}\匹配到aa ab ac. 

可按照\1[0-4][0-9]\匹配到⼩于15 

0的数字 

**(4)元字符 **

正则表达式的⼤部分元字符都以\开头 

\d数字字符 相当于[0-9] 

\w单词字符 代表所有的字⺟ 数字 下划线 相当于[a-zA-z0-9] 

\s空⽩符 代表tab和空⽩符 

\D ⾮数字字符 

\W ⾮单词字符 

\S ⾮空⽩字符 

. 代表除换⾏符以外的任意字符(如果要匹配.这个符号,可以⽤\.) 

^(⼦表达式) 只匹配字符⾸ ^a只匹配⾏头的a 

$(⼦表达式) 只匹配字符尾 $a只匹配⾏尾的a 

这⾥要和[^abc]区分,那个只是字符类运算符! 

**(5)正则表达式中的其他概念 **

贪婪与懒惰匹配 

*,+和{},会默认匹配尽可能多的字符,称贪婪匹配 

在其后加? 则切换为懒惰匹配 

例如<.+> +能够匹配⼦表达式.,即任意的⾮换⾏字符,因⽽整个正则表达式可以匹配除了换⾏符以外的整 

个⽂本 

<.+?><p> +还是能够匹配⼦表达式.但是由于?的存在,+只会选择.代表的⽂本中第⼀个字符匹配</p>
<p>例如⽂本为 abc def efg agh</p>
<p>&lt;.+&gt; 能匹配整个⽂本</p>
<p>&lt;.+?&gt; 只能以懒惰匹配识别包含于.的 a,匹配带有 a 的字符串.</p>
<p>参考视频</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1da4y1p7iZ/">https://www.bilibili.com/video/BV1da4y1p7iZ/</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2026/01/18/hello-world/" rel="prev" title="欢迎大家前来阅读文章">
      <i class="fa fa-chevron-left"></i> 欢迎大家前来阅读文章
    </a></div>
      <div class="post-nav-item">
    <a href="/2026/01/19/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" rel="next" title="第三章 文件包含">
      第三章 文件包含 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-RCE-%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">第二章 RCE 与正则表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-%E7%BB%AD%E4%B8%8A%E5%91%A8%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="nav-number">2.</span> <span class="nav-text">PHP 命令执行(续上周的学习)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E6%9B%BF%E6%8D%A2%E7%BB%95%E8%BF%87%E5%87%BD%E6%95%B0%E8%BF%87%E6%BB%A4-%E5%8D%B3%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E4%B8%8D%E8%A2%AB%E8%BF%87%E6%BB%A4%E7%9A%84%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">二 替换绕过函数过滤(即使用特定的函数或者不被过滤的函数执行命令)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9E%E6%8E%A5%E7%AC%A6"><span class="nav-number">2.2.</span> <span class="nav-text">三 操作系统连接符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E7%A9%BA%E6%A0%BC%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87"><span class="nav-number">2.3.</span> <span class="nav-text">四 空格过滤绕过</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%96%87%E4%BB%B6%E5%90%8D%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87"><span class="nav-number">2.4.</span> <span class="nav-text">五 文件名过滤绕过</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%8C%87%E4%BB%A4%E7%BB%95%E8%BF%87-%E9%80%9A%E5%B8%B8%E4%B8%BA%E8%BF%87%E6%BB%A4-cat"><span class="nav-number">2.5.</span> <span class="nav-text">六 常见文件读取指令绕过(通常为过滤 cat)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87-%E5%AF%B9%E6%8F%90%E4%BA%A4%E7%9A%84%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81"><span class="nav-number">2.6.</span> <span class="nav-text">七 编码绕过(对提交的命令进行编码)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E6%96%9C%E6%9D%A0%E7%BB%95%E8%BF%87"><span class="nav-number">2.7.</span> <span class="nav-text">*八 斜杠绕过</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D-%E5%A4%9A%E4%B8%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">2.8.</span> <span class="nav-text">*九 多个指令的执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP-%E5%87%BD%E6%95%B0%E5%AE%89%E5%85%A8"><span class="nav-number">3.</span> <span class="nav-text">PHP 函数安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-is-numeric-%E7%BB%95%E8%BF%87"><span class="nav-number">3.1.</span> <span class="nav-text">1.is_numeric 绕过</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">legend1440</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sun Jan 18 2026 08:00:00 GMT+0800 (GMT+08:00) – 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">legend1440</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
